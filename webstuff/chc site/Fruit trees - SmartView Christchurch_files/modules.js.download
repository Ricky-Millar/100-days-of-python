"use strict";

(function (app, riot) {
  var _feature = "batterycollection";
  var _page = "batterycollection";
  var _icon = "/assets/publica/sets/Find_Pin_Map.svg";
  app.modules.add(_feature, {
    location: {
      lat: 0,
      lng: 0
    },
    locationName: ""
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          url: _icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  }); //app.on("map/feature/detail/" + _feature, function (map, f, e) {

  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var popup = {
      detail: true,
      data: {
        title: f.getProperty("sitename"),
        sub: f.getProperty("sitetype"),
        details: [{
          svgIcon: "Date",
          label: "Opening hours",
          value: f.getProperty("openinghours")
        }, {
          svgIcon: "Location",
          label: "Address",
          value: f.getProperty("siteaddress")
        }, {
          label: "Instructions",
          value: f.getProperty("instructions")
        }, {
          label: "Further information",
          link: f.getProperty("forfurtherinformation"),
          value: "CCC website"
        }] //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
  });
})(app, riot);

(function (app, riot) {
  var _feature = "bikeshare";
  var _icon = "/assets/pointer/web-pointers-bikeshare.svg";
  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("name"),
        desc: a.getProperty("bikes"),
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var html = f.getProperty("name");
    html += "<br>Available bikes: " + f.getProperty("bikes");
    html += "<br>Free racks: " + f.getProperty("free_racks");
    var data = {
      location: {
        lat: e.latLng.lat(),
        lng: e.latLng.lng()
      },
      detail: {
        name: f.getProperty("Name"),
        info: [{
          label: "Grade",
          text: f.getProperty("Grade")
        }, {
          label: "Warning",
          text: f.getProperty("Warning")
        }]
      }
    };
    var popup = {
      detail: true,
      content: html,
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          url: _icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "bike-tracks";
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var html = f.getProperty("Name");
    html += "<br>" + f.getProperty("track_type");
    var data = {
      location: {
        lat: e.latLng.lat(),
        lng: e.latLng.lng()
      },
      content: html
    };
    route(location.hash.replace("#map", "selection").replace("#smartmap", "selection"), {
      data: data
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      var color;

      switch (feat.getProperty("track_type")) {
        case "cyclelanes":
          color = "#008FF3";
          break;

        case "cycleways":
        case "cycleway":
          color = "#0C0";
          break;

        case "mountainbike":
          color = "#FF7E00";
          break;

        case "prohibited":
          color = "black";
          break;
      }

      riot.util.misc.extend(_style, {
        strokeColor: color
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "bike-tracks2";
  var _lastSelectedFeature = null;
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var html = "";
    var notinclude = {
      ccc: true,
      feature: true,
      relations: true,
      popup: true,
      website: function website(v, p) {
        detail.link = v;
      },
      name: function name(v, p) {
        if (!detail.name && p == "name") {
          detail.name = v;
          return;
        } else if (p == "name") {
          detail.info.push({
            label: "Route",
            text: v
          });
        }
      }
    };
    var detail = {};

    if (f.getProperty("name")) {
      detail.name = f.getProperty("name");
    }

    detail.info = [];
    f.forEachProperty(function (v, p) {
      html += "<br>" + p + ": " + v;

      if (!notinclude[p]) {
        detail.info.push({
          label: p,
          text: v
        });
      } else if (notinclude[p].call) {
        notinclude[p](v, p);
      }
    });

    if (f.getProperty("relations")) {
      var rels = f.getProperty("relations");
      rels.forEach(function (a) {
        var relfeat = map.data.getFeatureById(_feature + "." + a); // _activeIds.push(a);

        html += "<br><b>Route</b>";
        relfeat.forEachProperty(function (v, p) {
          html += "<br>" + p + ": " + v;

          if (!notinclude[p]) {
            detail.info.push({
              label: p,
              text: v
            });
          } else if (notinclude[p].call) {
            notinclude[p](v, p);
          }
        });
      });
    }

    detail.info.sort(function (a, b) {
      if (a.label == "description") return -1;
      if (b.label == "description") return 1;else return 0;
    });
    var data = {
      location: {
        lat: e.latLng.lat(),
        lng: e.latLng.lng()
      },
      detail: detail
    };

    if (_lastSelectedFeature) {
      if (f.getGeometry().getType() == "MultiLineString") {
        $mn.isMap().data.revertStyle(f);
      } else if (_lastSelectedFeature.getProperty("polyline")) {
        _lastSelectedFeature.getProperty("polyline").setOptions({
          strokeOpacity: "0"
        });
      }

      _lastSelectedFeature = null;
    }

    if (f.getGeometry().getType() == "MultiLineString") {
      $mn.isMap().data.overrideStyle(f, {
        strokeOpacity: 1,
        strokeWidth: 8
      });
    } else if (f.getProperty("polyline")) {
      f.getProperty("polyline").setOptions({
        strokeOpacity: "0.3"
      });
      _lastSelectedFeature = f;
    }

    var detail = getDetailInfo(f);
    var html = "<h3>".concat(detail.title, "</h3>");
    if (detail.description) html += "<p>".concat(detail.description, "</p>");
    detail.more.forEach(function (a) {
      html += "".concat(a, "<br>");
    });

    if (detail.noosm) {} else {
      html += "<p><em>Data crowdsourced through <a href='https://www.openstreetmap.org/' target=_blank>OpenStreetMaps</a>. To help other cyclists, you can update OSM yourself!</em></p>";
    }

    console.log(f, detail);
    var popup = {
      detail: true,
      content: html,
      closeBack: function closeBack() {
        if (f.getGeometry().getType() == "MultiLineString") {
          $mn.isMap().data.revertStyle(f);
        } else if (f.getProperty("polyline")) {
          f.getProperty("polyline").setOptions({
            strokeOpacity: "0"
          });
        }
      }
    };
    app.tags.map.update({
      popup: popup
    });
  });

  function getDetailInfo(feat) {
    var detail = {
      more: []
    }; //ferry_terminal

    if (feat.getProperty("amenity") == "ferry_terminal") {
      detail.title = "Ferry terminal";
      /*  if (feat.getProperty("name")) {
           detail.description = feat.getProperty("name");
       } */
      // detail.noosm = true;
    }

    if (feat.getProperty("amenity") == "ebike-station") {
      detail.title = "E-Bike charging stations";

      if (feat.getProperty("name")) {
        detail.description = feat.getProperty("name");
      }

      detail.noosm = true;
    } else if (feat.getProperty("group") == "parking") {
      detail.title = "Bicycle parking";

      if (feat.getProperty("note")) {
        detail.description = feat.getProperty("note");
      }

      if (feat.getProperty("capacity")) {
        detail.more.push("Capacity: " + feat.getProperty("capacity"));
      }

      if (feat.getProperty("covered")) {
        detail.more.push("Covered: " + feat.getProperty("covered"));
      }
    } else if (feat.getProperty("group") == "repair") {
      detail.title = "Repair station";

      if (feat.getProperty("note")) {
        detail.description = feat.getProperty("note");
      }

      if (feat.getProperty("opening_hours")) {
        detail.more.push("Opening hours: " + feat.getProperty("opening_hours"));
      }
    } else if (feat.getProperty("group") == "mtb") {
      detail.title = "Mountain Bike Track";

      if (feat.getProperty("name")) {
        detail.title = feat.getProperty("name");
      }

      if (feat.getProperty("note")) {
        detail.description = feat.getProperty("note");
      }

      if (feat.getProperty("surface")) {
        detail.more.push("Surface: " + feat.getProperty("surface"));
      }

      if (feat.getProperty("mtb:scale:nz") && feat.getProperty("mtb:scale:nz") > 0) {
        detail.more.push("Grade: " + feat.getProperty("mtb:scale:nz"));
      } else if (feat.getProperty("mtb:scale") && feat.getProperty("mtb:scale") > 0) {
        detail.more.push("Grade: " + feat.getProperty("mtb:scale"));
      } else if (feat.getProperty("tracktype")) {
        detail.more.push("Grade: " + feat.getProperty("mtb:scale").replace("grade", ""));
      }

      if (feat.getProperty("website")) {
        detail.more.push("Website: " + feat.getProperty("website"));
      }
    } else if (feat.getProperty("group") == "route" || feat.getProperty("group") == "lcn") {
      detail.title = "Cycling route / major cycleway";

      if (feat.getProperty("name")) {
        detail.title = feat.getProperty("name");
      }

      if (feat.getProperty("note")) {
        detail.description = feat.getProperty("note");
      }

      if (feat.getProperty("description")) {
        detail.description = feat.getProperty("description");
      }

      if (feat.getProperty("website")) {
        detail.more.push("Website: " + feat.getProperty("website"));
      }

      detail.more.push("Mainly separated from the roadway with a range of special features to help make cycling safer.");
    } else if (feat.getProperty("group") == "cycleway") {
      detail.title = "Cycleway";

      if (feat.getProperty("name")) {
        detail.title = feat.getProperty("name");
      }

      if (feat.getProperty("note")) {
        detail.description = feat.getProperty("note");
      }

      if (feat.getProperty("description")) {
        detail.description = feat.getProperty("description");
      }

      if (feat.getProperty("destination")) {
        detail.description = feat.getProperty("description");
      }

      if (feat.getProperty("website")) {
        detail.more.push("Website: " + feat.getProperty("website"));
      }

      detail.more.push("Mainly separated from the roadway with a range of special features to help make cycling safer.");
    } else if (feat.getProperty("group") == "cyclelane") {
      detail.title = "Cyclelane";

      if (feat.getProperty("name")) {
        detail.title = feat.getProperty("name");
      }

      if (feat.getProperty("note")) {
        detail.description = feat.getProperty("note");
      }

      if (feat.getProperty("description")) {
        detail.description = feat.getProperty("description");
      }

      if (feat.getProperty("destination")) {
        detail.description = feat.getProperty("description");
      }

      if (feat.getProperty("website")) {
        detail.more.push("Website: " + feat.getProperty("website"));
      }

      detail.more.push("A designated strip on the roadway of busy roads.");
    } else if (feat.getProperty("group") == "bicycle" || feat.getProperty("group") == "unknown") {
      detail.title = "Other cycling tracks/lanes";

      if (feat.getProperty("name")) {
        detail.title = feat.getProperty("name");
      }

      if (feat.getProperty("note")) {
        detail.description = feat.getProperty("note");
      }

      if (feat.getProperty("description")) {
        detail.description = feat.getProperty("description");
      }

      if (feat.getProperty("destination")) {
        detail.description = feat.getProperty("description");
      }

      if (feat.getProperty("website")) {
        detail.more.push("Website: " + feat.getProperty("website"));
      }
    }

    return detail;
  }

  $mn.on("feature/remove", function (feature) {
    var feat = feature.feature;

    if (feat.getProperty("feature") == _feature) {
      var poly = feat.getProperty("polyline");

      if (poly) {
        poly.setMap(null);
      }
    }
  });
  $mn.on("feature/add", function (feature) {
    var feat = feature.feature;

    if (feat && feat.getProperty && feat.getProperty("feature") == _feature) {
      if (feat.getProperty("cycleway") == "no" || feat.getProperty("cycleway:right") == "no" || feat.getProperty("cycleway:left") == "no" || feat.getProperty("bicycle") == "no") {
        feat.setProperty("group", "nocycle");
      } else if (feat.getProperty("amenity") == "ferry_terminal") {
        feat.setProperty("group", "ferry_terminal");
      } else if (feat.getProperty("amenity") == "ebike-station") {
        feat.setProperty("group", "ebike");
      } else if (feat.getProperty("amenity") == "bicycle_parking") {
        feat.setProperty("group", "parking");
      } else if (feat.getProperty("amenity") == "bicycle_repair_station") {
        feat.setProperty("group", "repair");
      } else if (feat.getProperty("route") == "bicycle" && feat.getProperty("network") == "lcn") {
        feat.setProperty("group", "lcn");
      } else if (feat.getProperty("mtb") == "yes") {
        feat.setProperty("group", "mtb");
      } else if (feat.getProperty("route") == "mtb") {
        feat.setProperty("group", "mtb");
      } else if (feat.getProperty("route") || feat.getProperty("lcn") == "yes") {
        feat.setProperty("group", "route");
      } else if (feat.getProperty("mtb:scale:nz")) {
        feat.setProperty("group", "mtb");
      } else if (feat.getProperty("mtb:scale:imba")) {
        feat.setProperty("group", "mtb");
      } else if (feat.getProperty("mtb:scale")) {
        feat.setProperty("group", "mtb");
      } else if (feat.getProperty("highway") == "cycleway" || feat.getProperty("cycleway") == "yes" || feat.getProperty("cycleway") == "track" || feat.getProperty("cycleway") == "crossing" || feat.getProperty("cycleway:left") == "track" || feat.getProperty("cycleway:right") == "track" || feat.getProperty("cycleway:both") == "track" || feat.getProperty("cycleway") == "opposite" || feat.getProperty("cycleway:right") == "opposite" || feat.getProperty("cycleway:left") == "opposite" || feat.getProperty("cycleway:both") == "opposite" || feat.getProperty("cycleway") == "opposite_lane" || feat.getProperty("cycleway:right") == "opposite_lane" || feat.getProperty("cycleway:left") == "opposite_lane" || feat.getProperty("cycleway:both") == "opposite_lane" || feat.getProperty("bicycle") == "designated") {
        feat.setProperty("group", "cycleway");
      } else if (feat.getProperty("cycleway") == "lane" || feat.getProperty("oneway:bicycle") == "yes" || feat.getProperty("cycleway") == "shared_lane" || feat.getProperty("cycleway:left") == "shared_lane" || feat.getProperty("cycleway:right") == "shared_lane" || feat.getProperty("cycleway:both") == "shared_lane" || feat.getProperty("cycleway") == "use_sidewalk" || feat.getProperty("cycleway:left") == "use_sidewalk" || feat.getProperty("cycleway:right") == "use_sidewalk" || feat.getProperty("cycleway:both") == "use_sidewalk" || feat.getProperty("cycleway") == "share_sidewalk" || feat.getProperty("cycleway:left") == "share_sidewalk" || feat.getProperty("cycleway:right") == "share_sidewalk" || feat.getProperty("cycleway:both") == "share_sidewalk" || feat.getProperty("cycleway") == "shared_busway" || feat.getProperty("cycleway:left") == "shared_busway" || feat.getProperty("cycleway:right") == "shared_busway" || feat.getProperty("cycleway:both") == "shared_busway" || feat.getProperty("cycleway") == "share_busway" || feat.getProperty("cycleway:left") == "share_busway" || feat.getProperty("cycleway:right") == "share_busway" || feat.getProperty("cycleway:both") == "share_busway" || feat.getProperty("cycleway:left") == "lane" || feat.getProperty("cycleway:right") == "lane" || feat.getProperty("cycleway:both") == "lane" || feat.getProperty("cycleway:left") == "separate" || feat.getProperty("cycleway:right") == "separate" || feat.getProperty("cycleway:both") == "separate" || feat.getProperty("cycleway:left") == "seperate" || feat.getProperty("cycleway:right") == "seperate" || feat.getProperty("cycleway:both") == "seperate" || feat.getProperty("cycleway") == "1" || feat.getProperty("cycleway:left") == "1" || feat.getProperty("cycleway:right") == "1" || feat.getProperty("cycleway:both") == "1" || feat.getProperty("cycleway") == "l" || feat.getProperty("cycleway:left") == "l" || feat.getProperty("cycleway:right") == "l" || feat.getProperty("cycleway:both") == "l") {
        feat.setProperty("group", "cyclelane");
      } else if (feat.getProperty("bicycle") == "yes") {
        feat.setProperty("group", "bicycle");
      } else if (feat.getProperty("relations")) {
        feat.setProperty("group", "relation");
      } else {
        //console.log(feat);
        feat.setProperty("group", "unknown");
      }

      if (["MultiLineString", "LineString"].some(function (a) {
        return a == feat.getGeometry().getType();
      })) {
        /* if (feat.getGeometry().getType() == "MultiLineString") {
             console.log(feat);
         }*/
        var arr = _lib.flattenDeep(feat.getGeometry().getArray()); //  console.log(arr);


        var poly = new google.maps.Polyline({
          path: arr,
          map: $mn.isMap(),
          strokeColor: "black",
          strokeOpacity: 0,
          strokeWeight: 10
        });
        poly.addListener("click", function (e) {
          app.trigger("map/feature/detail/" + _feature, $mn.isMap(), feat, e);
        });
        feat.setProperty("polyline", poly);
      }
    }
  });
  $mn.on("layer/loaded/" + _feature, function (list) {
    var _legend = {
      legend: {
        list: [],
        name: _feature,
        collapse: true
      }
    };

    _legend.legend.list.push({
      line: "green",
      label: "Mountain bike"
    });

    _legend.legend.list.push({
      line: "gold",
      label: "Major cycle route"
    });

    _legend.legend.list.push({
      line: "purple",
      label: "Cycle route"
    });

    _legend.legend.list.push({
      line: "orange",
      label: "Cycleway"
    });

    _legend.legend.list.push({
      line: "green",
      label: "Cycle lane"
    });

    _legend.legend.list.push({
      line: "#3b69b2",
      label: "Other cycling friendly"
    });

    app.maplegend.init(_legend.legend).update();
  });

  var getStyle = function getStyle(feat) {
    var zoom = $mn.zoom(); //if (!zoom) zoom = 17;
    //zoom = 17;

    var newstyle;
    var dash = {
      path: 'M 0,-1 0,1',
      strokeOpacity: 1,
      scale: 2
    };
    var mtb = {
      visible: zoom >= 13,
      zIndex: 10,
      strokeOpacity: 0.01,
      strokeColor: "green",
      strokeWeight: "6",
      icons: [{
        icon: dash,
        offset: '0',
        repeat: '10px'
      }]
    };
    var lcn = {
      visible: true,
      zIndex: 0,
      strokeOpacity: zoom < 13 ? 0.8 : 0.4,
      strokeColor: "gold",
      strokeWeight: zoom < 13 ? 5 : "10"
    };
    var route = {
      visible: true,
      zIndex: 0,
      strokeOpacity: zoom < 13 ? 0.8 : 0.4,
      strokeColor: "purple",
      strokeWeight: zoom < 13 ? 5 : "10"
    };
    var cycleway = {
      visible: zoom >= 13,
      strokeOpacity: 1,
      zIndex: 5,
      strokeColor: "orange",
      strokeWeight: zoom < 15 ? 2 : 4
    };
    var cyclelane = {
      visible: zoom >= 13,
      strokeOpacity: 1,
      zIndex: 5,
      strokeColor: "green",
      strokeWeight: zoom < 15 ? 2 : 4
    };
    var bicycle = {
      strokeColor: "#3b69b2",
      strokeWeight: 2,
      zIndex: 5,
      visible: zoom >= 15
    };
    var others = {
      visible: zoom >= 13,
      zIndex: 5,
      strokeColor: "#3b69b2",
      strokeWeight: 2
    };

    if (feat.getProperty("group") == "nocycle") {
      newstyle = {
        visible: false
      };
    } else if (feat.getProperty("group") == "parking") {
      newstyle = {
        visible: zoom >= 17,
        icon: {
          url: "/assets/pointer/web-pointers-bike park-26.svg",
          scaledSize: app.conf.mapIconSize()
        }
      };
    } else if (feat.getProperty("group") == "repair") {
      newstyle = {
        visible: zoom >= 17,
        icon: {
          url: "/assets/pointer/web-pointers-star.svg",
          scaledSize: app.conf.mapIconSize()
        }
      };
    } else if (feat.getProperty("group") == "ebike") {
      newstyle = {
        visible: zoom >= 17,
        icon: {
          url: "/assets/pointer/web-pointers-star.svg",
          scaledSize: app.conf.mapIconSize()
        }
      };
    } else if (feat.getProperty("group") == "lcn") {
      newstyle = lcn;
    } else if (feat.getProperty("group") == "mtb") {
      newstyle = mtb;
    } else if (feat.getProperty("group") == "route") {
      newstyle = route; // console.log(feat);
    } else if (feat.getProperty("group") == "cycleway") {
      newstyle = cycleway;
    } else if (feat.getProperty("group") == "cyclelane") {
      newstyle = cyclelane;
    } else if (feat.getProperty("group") == "bicycle") {
      newstyle = bicycle;
    } else if (feat.getProperty("group") == "relation") {
      newstyle = {
        visible: false
      };
    } else if (feat.getProperty("group") == "unknown") {
      console.log(feat);
      newstyle = {
        visible: false
      };
    } else {
      console.log(feat);
      newstyle = others;
    }

    return newstyle;
  };

  var zoomTimeout;
  $mn.one("map/idle", function () {
    $mn.isMap().addListener('zoom_changed', function () {
      var map = $mn.isMap();
      var zoom = $mn.zoom();
      /* if (zoom > 17 && $mn.lastZoom() > 17) return;
      else if (zoom < 13 && $mn.lastZoom() < 13) return;
      else if (!(zoom < 17 && $mn.lastZoom() > 13)) return;
      */

      setTimeout(function () {
        map.data.forEach(function (f) {
          if (f.getProperty("feature") == _feature) {
            map.data.overrideStyle(f, getStyle(f));
          }
        });
      }, 100);
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};
    var newstyle;

    if (feat.getProperty("feature") == _feature) {
      newstyle = getStyle(feat);
      riot.util.misc.extend(_style, newstyle);
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "binsensor";
  var _icon = "/assets/my/web-pointers-bin.svg";
  var _legend = {
    legend: {
      list: [{
        icon: "/assets/my/binsensor/web-pointers-bin-sensor-35.svg",
        label: "Data older than 1 day"
      }, {
        icon: "/assets/my/binsensor/web-pointers-bin-sensor-empty-35.svg",
        label: "Less than 25%"
      }, {
        icon: "/assets/my/binsensor/web-pointers-bin-sensor-used-35.svg",
        label: "Between 25% and 85%"
      }, {
        icon: "/assets/my/binsensor/web-pointers-bin-sensor-full-35.svg",
        label: "More than 85%"
      }]
    }
  };
  /*  if (feat.getProperty("Status") < 25) {
              icon = "/assets/my/binsensor/web-pointers-bin-sensor-empty-35.svg";
          } else if (feat.getProperty("Status") < 85) {
              icon = "/assets/my/binsensor/web-pointers-bin-sensor-used-35.svg";
          } else {
              icon = "/assets/my/binsensor/web-pointers-bin-sensor-full-35.svg";
          }*/

  $mn.on("layer/loaded/" + _feature, function (list) {
    app.maplegend.init(_legend.legend).update();
  });
  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      var icon = _icon;

      if (a.getProperty("Status") < 25) {
        icon = "/assets/my/binsensor/web-pointers-bin-sensor-empty-35.svg";
      } else if (a.getProperty("Status") < 85) {
        icon = "/assets/my/binsensor/web-pointers-bin-sensor-used-35.svg";
      } else {
        icon = "/assets/my/binsensor/web-pointers-bin-sensor-full-35.svg";
      }

      return {
        icon: icon,
        name: a.getProperty("name"),
        desc: a.getProperty("Status"),
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Bin sensor directory",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("name"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var popup = {
      detail: true,
      data: {
        title: f.getProperty("name"),
        sub: f.getProperty("mylevel") + "% full",
        details: [{
          svgIcon: "Time",
          label: "last update",
          value: f.getProperty("LastReceived")
        }] //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
    return;
    var html = f.getProperty("name");
    html += " <br>" + f.getProperty("Status") + "% full at " + f.getProperty("LastReceived");
    var popup = {
      detail: true,
      content: html,
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      var icon = _icon;
      var zindex = 1;

      if (feat.getProperty("Status") < 25) {
        icon = "/assets/my/binsensor/web-pointers-bin-sensor-empty-35.svg";
      } else if (feat.getProperty("Status") < 85) {
        icon = "/assets/my/binsensor/web-pointers-bin-sensor-used-35.svg";
      } else {
        icon = "/assets/my/binsensor/web-pointers-bin-sensor-full-35.svg";
      }

      if (moment(feat.getProperty("LastReceived")).add(1, 'day').isBefore()) {
        icon = "/assets/my/binsensor/web-pointers-bin-sensor-35.svg";
      }

      riot.util.misc.extend(_style, {
        icon: {
          url: icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2",
        zIndex: zindex
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "bus-stops";
  var _icon = "assets/icons/black/bus.png";
  var _cacheBusTimes = [];
  var resizeTimeout;
  var txtOverlays = [];
  var waitTillFinish;
  var interval;
  app.on("search/click/" + "busstops", function (item) {
    route("map", {
      detail: _feature,
      map: {
        center: item.obj.data.location,
        zoom: 17,
        clear: true
      },
      clear: true
    });
  }); //

  app.on("search/query", function (q, cb, register) {
    register(_feature, true);

    _lib.ajax.$get("/app/router/search.php?busstops&q=" + q, function (data) {
      var results = [];
      var json = JSON.parse(data);
      if (json && Array.isArray(json.list)) json.list.forEach(function (item) {
        results.push({
          options: json.options,
          label: item.label,
          type: "Bus Stops",
          dataset: "busstops",
          obj: item,
          image: _icon
        });
      });
      cb(results, _feature);
    });
  });

  var loadDetailsOnBoundsChange = function loadDetailsOnBoundsChange(map) {
    var _features = [];
    map = app.gmap.map;
    app.gmap.map.data.forEach(function (a) {
      if (a.getProperty("feature") == _feature) {
        _features.push(a);
      }
    });
    if (_features.length == 0) return;
    clearTimeout(resizeTimeout);

    if (_features && Object.keys && Object.keys(_features).length == 0) {
      for (var i = 0; i < txtOverlays.length; i++) {
        txtOverlays[i].setMap(null);
      }
    }

    if (map.getZoom() >= ($mn.layers.has("bus-routes") ? 16 : 15) && _features) {
      var feats = _features;
      var visf = [];

      for (i in feats) {
        feats[i].getGeometry().forEachLatLng(function (a, b) {
          if (map.getBounds().contains(a)) visf.push(feats[i]);
        });
      }

      if (visf.length < 35) {
        resizeTimeout = setTimeout(function () {
          for (var i = 0; i < txtOverlays.length; i++) {
            txtOverlays[i].setMap(null);
          }

          for (i = 0; i < visf.length; i++) {
            var id = visf[i].getProperty("PlatformID");

            var showPlatformTime = function showPlatformTime(id, json, vis, map, cache) {
              var html = "";
              var trips = [];
              html += "<div class='map-bus-stop-title'>" + vis.getProperty("Name") + "</div>";

              for (var i in json) {
                if (i == "timestamp") continue;
                html += "<div class='map-bus-stop map-bus-" + i + "'>";
                html += i + ": ";
                trips = [];
                trips.push(json[i][0] + "min");
                html += trips.join(", ");
                html += "</div>";
              }

              var newOverlay = new _maps.TxtOverlay(vis.getGeometry().get(), html, "customBox", map);
              txtOverlays.push(newOverlay);
              google.maps.event.addDomListener(newOverlay.div_, "click", function () {
                var mev = {
                  stop: null,
                  feature: vis
                };
                google.maps.event.trigger(map.data, "click", mev);
              });
            };

            (function (id, vis, map) {
              getTimesById(id, function (id, data) {
                showPlatformTime(id, data, vis, map);
              });
            })(id, visf[i], map);
          }
        }, 200);
      }
    } else {
      for (i = 0; i < txtOverlays.length; i++) {
        txtOverlays[i].setMap(null);
      }
    }
  };

  var showDetail = function showDetail(map, feat) {
    var mainHtml = feat.getProperty("Name") + "<br>" + feat.getProperty("Routes");
    /*  +
                "<br>" +
                feat.getProperty("Service"); */

    var detail = {
      name: feat.getProperty("Name"),
      info: [{
        label: "Routes",
        text: feat.getProperty("Routes")
      }]
    };

    (function (platformID) {
      var showPlatformTime = function showPlatformTime(platformID, json) {
        var html = "";
        var trips = [];
        var popupList = []; //{image:image, label:label, value:value}

        for (var i in json) {
          if (i == "timestamp") continue;
          html += "<br>" + i + ": ";
          trips = [];

          for (var j in json[i]) {
            trips.push(json[i][j] + "min");
            popupList.push({
              image: "/assets/publica/sets/OnTheGo_Time.svg",
              label: i,
              value: json[i][j] + "min"
            });
          }

          detail.info.push({
            label: i,
            text: trips.join(", ")
          });
          html += trips.join(", ");
        }

        var data = {
          location: _maps.latlng2Scalar(feat.getGeometry().get()),
          map: {
            center: _maps.latlng2Scalar(feat.getGeometry().get())
          },

          /* content: mainHtml + html */
          detail: detail
        };
        /*
        <div class="detail-section detail-data detail-flex flex-left">  
        
        <input type="range" style="width:100%">
        <table style="width:100%">
            <tr><th>Route<th>Time<th>Day
                <tr><td>3 Sheffield Cres<th>10:38<th>Mon,Wed,Thu,Tue,Fri
            </table>
        </div>
        */

        var popup = {
          detail: true,
          data: {
            title: feat.getProperty("Name"),
            sub: feat.getProperty("Routes"),
            preloadDetail: true,
            tag: "popup-busstop",
            data: {
              id: feat.getProperty("oid")
            },

            /*    content: "Content",  */
            fav: {
              label: feat.getProperty("Name"),
              page: "travel",
              detail: "busstops",
              url: "map/layer/bus-stops/@" + feat.getGeometry().get().lng() + "," + feat.getGeometry().get().lat() + ",20",
              id: feat.getProperty("PlatformID"),
              update_on: new Date(),
              expire_after: {
                val: 2,
                dim: "minutes"
              },
              data: popupList.reduce(function (r, o) {
                r.push({
                  title: o.label,
                  value: o.value,
                  icon: o.image
                });
                return r;
              }, []),
              alertText: "Try to favourite a bus stop<br> to see it's schedule <br>on the home page"
            } //content: html

          } // marker: feat

        }; //  console.log(popup);

        app.tags.map.update({
          popup: popup
        });
      };

      getTimesById(platformID, showPlatformTime);
    })(feat.getProperty("PlatformID"));
  };

  app.on("map/feature/detail/" + _feature, function (map, f) {
    showDetail(map, f);
  });
  app.on("map/bounds/changed", function (map, e) {
    clearTimeout(waitTillFinish);
    waitTillFinish = setTimeout(function () {
      loadDetailsOnBoundsChange(map);
    }, 10);
  });
  app.on("map/feature/remove", function (map, f) {
    app.promise.mapLayer().then(function () {
      clearTimeout(waitTillFinish);

      if (f && f.feature && f.feature.getProperty("feature") == _feature && txtOverlays.length > 0) {
        for (var i = 0; i < txtOverlays.length; i++) {
          txtOverlays[i].setMap(null);
        }
      }
    });
  });
  /*
   a.distance = _maps.distance(
                      lat,
                      lng,
                      app.lastPosition.lat,
                      app.lastPosition.lng
                  );
  */

  app.on("map/data/" + _feature, function (list) {
    app.alert.set({
      title: "Bus stops directory",
      list: list.sort(function (a, b) {
        if (!a.getProperty("distance")) {
          a.setProperty("distance", _maps.distance(a.getGeometry().get().lat(), a.getGeometry().get().lng(), app.lastPosition.lat, app.lastPosition.lng));
        }

        if (!b.getProperty("distance")) {
          b.setProperty("distance", _maps.distance(b.getGeometry().get().lat(), b.getGeometry().get().lng(), app.lastPosition.lat, app.lastPosition.lng));
        }

        return a.getProperty("distance") < b.getProperty("distance") ? -1 : 1;
      }).reduce(function (r, a) {
        r.push({
          title: a.getProperty("Name"),
          feat: a,
          extra: [_maps.distanceRoundFormat(a.getProperty("distance")), a.getProperty("Routes")]
        });
        return r;
      }, []),
      collapsed: true
    });
  });
  /* $mn.on('layer/loaded/' + _feature, function(list) {
      app.alert.set({
          title: "Bus stops directory",
          list: list,
          collapsed: true
      });
  }); */

  app.on("map/feature/add", function (map, f) {
    /*  if (f && f.feature && f.feature.getProperty("feature") == _feature) {
         app.alert.set({
             title: "Bus stops directory",
             list: 
             collapsed: true
         });
     } */
    if (f && f.feature && f.feature.getProperty("feature") == _feature && $mn.layers.has("bus-routes")) {
      f.feature.setProperty("r", 0.5);
    }

    app.promise.mapLayer().then(function () {
      clearTimeout(waitTillFinish);
      waitTillFinish = setTimeout(function () {
        loadDetailsOnBoundsChange(map);
      }, 10);
    });
  });
  app.on("map/feature/style", function (feat, style) {
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      var visible = true;

      if ($mn.layers.has("bus-routes") && $mn.isMap().getZoom() < 16) {
        visible = false;
      }

      riot.util.misc.extend(_style, {
        icon: {
          url: "/assets/publica/sets/OnTheGo_Pin_Map.svg",
          //"/assets/pointer/web-pointers-bus.svg",
          scaledSize: app.conf.mapIconSize(0.5)
        },
        visible: visible
      });
    }

    riot.util.misc.extend(style, _style);
  });

  var getTimesById = function getTimesById(id, cb) {
    var now = new Date();

    if (_cacheBusTimes[id] && now - _cacheBusTimes[id].timestamp < 1000 * 30) {
      cb(id, _cacheBusTimes[id]);
    } else {
      _lib.ajax.$get("/app/router/bus_platform_time.php?PlatformID=" + id, function (data) {
        var json = JSON.parse(data);
        json.timestamp = new Date();
        _cacheBusTimes[id] = json;
        cb(id, json);
      });
    }
  };
})(app, riot);

(function (app, riot) {
  var _feature = "bus-routes";
  var _icon = "assets/icons/black/bus.png"; // var bus_routes_colors = { "85": "241,91,76,255", "17": "236,0,140,255", "28": "247,147,40,255", "29": "0,83,159,255", "44": "0,116,173,255", "60": "218,111,171,255", "80": "113,125,189,255", "95": "179,136,8,255", "100": "136,128,126,255", "107": "70,162,153,255", "108": "162,133,179,255", "120": "250,166,26,255", "125": "95,153,55,255", "130": "159,57,37,255", "135": "13,177,75,255", "140": "0,146,158,255", "145": "149,100,56,255", "150": "152,83,161,255", "535": "210,191,165,255", "820": "70,186,124,255", "951": "0,157,178,255", "952": "128,206,202,255", "960": "241,91,78,255", "B": "62,188,237,255", "F": "0,88,153,255", "Gl": "255,218,0,255", "Gr": "0,182,181,255", "O": "243,112,33,255", "Oc": "243,112,33,255", "Oa": "243,112,33,255", "Or": "121,188,67,255", "P": "85,69,136,255", "TL": "191,110,173,255", "W": "0,182,181,255", "Y": "255,194,14,255" };

  var bus_routes_colors = app.conf.bus_routes_colors; //{ "85": "241,91,76,255", "17": "236,0,140,255", "28": "247,147,40,255", "29": "0,83,159,255", "44": "0,116,173,255", "60": "218,111,171,255", "80": "113,125,189,255", "95": "179,136,8,255", "100": "136,128,126,255", "107": "70,162,153,255", "108": "162,133,179,255", "120": "250,166,26,255", "125": "95,153,55,255", "130": "159,57,37,255", "135": "13,177,75,255", "140": "0,146,158,255", "145": "149,100,56,255", "150": "152,83,161,255", "535": "210,191,165,255", "820": "70,186,124,255", "951": "0,157,178,255", "952": "128,206,202,255", "960": "241,91,78,255", "B": "62,188,237,255", "F": "0,88,153,255", "Gl": "255,218,0,255", "Gr": "0,182,181,255", "O": "243,112,33,255", "Oc": "121,188,67,255", "Or": "121,188,67,255", "Oa": "121,188,67,255", "P": "85,69,136,255", "TL": "191,110,173,255", "W": "0,182,181,255", "Y": "255,194,14,255" };

  var atleastOne = false;

  var _boundsTT;

  var _visible = false;
  var _legend = {
    legend: {
      list: []
    }
  };

  function legendRefresh() {
    clearTimeout(_boundsTT);

    if ($mn.layers.has(_feature)) {
      if (_legend.legend.list.length > 0 && app.tags.mapLegend) {
        _boundsTT = setTimeout(function () {
          var legfilter = {
            legend: {
              list: []
            }
          };
          legfilter.legend.list = _legend.legend.list.filter(function (a) {
            return $mn.layers.getVisible().some(function (b) {
              return a.label == b.getProperty('RouteName');
            });
          }); //app.tags.mapLegend.update({ opts: { dataLegend: legfilter.legend, clearLegend:true } })

          app.maplegend.init(legfilter.legend).update();
          $mn.one('bounds/changed', legendRefresh);
        }, 500);
      } else {
        $mn.one('bounds/changed', legendRefresh);
      }
    }
  }

  $mn.on('layer/loaded/' + _feature, function (list) {
    var routes = list.reduce(function (r, a) {
      r[a.getProperty("RouteName")] = true;
      return r;
    }, {});
    routes = Object.keys(routes);
    routes.forEach(function (a) {
      _legend.legend.list.push({
        line: "rgba(" + bus_routes_colors.get(a) + ")",
        label: a
      });
    });
    var legfilter = {
      legend: {
        list: []
      }
    };
    legfilter.legend.list = _legend.legend.list.filter(function (a) {
      return $mn.layers.getVisible().some(function (b) {
        return a.label == b.getProperty('RouteName');
      });
    }); //app.tags.map.update(legfilter)

    app.maplegend.init(legfilter.legend).update();
    _visible = true;
    $mn.one('bounds/changed', legendRefresh);
  });

  function clickRoutes(e) {
    var list = [];
    var changed = false;
    atleastOne = false;
    $mn.isMap().data.forEach(function (a) {
      if (a.getProperty("feature") == _feature) {
        var poly;

        if (a.getProperty("poly")) {
          poly = a.getProperty("poly");
        } else {
          poly = new google.maps.Polyline({
            path: a.getGeometry().getArray(),
            map: $mn.isMap(),
            visible: false,
            strokeColor: "black",
            strokeWeight: 10,
            zIndex: 0
          });
          a.setProperty("poly", poly);
        }

        if (google.maps.geometry.poly.isLocationOnEdge(e.latLng, poly, 0.0005)) {
          if (!poly.getVisible()) {
            changed = true;
          }

          poly.setVisible(true);
          a.setProperty("clicked", true);
          list.push(a);
          atleastOne = true;
        } else {
          if (poly.getVisible()) {
            changed = true;
          }

          poly.setVisible(false);
          a.setProperty("clicked", false);
        }
      }
    });
    /* var names = list.reduce((a, b) => {
         return a.concat([b.getProperty("Name")]);
     }, []).filter((v, i, s) => s.indexOf(v) === i).join(", ");
     console.log(names);*/

    if (list.length > 0) {
      list = list.reduce(function (a, b) {
        if (!a.some(function (c) {
          return c.getProperty("Name") == b.getProperty("Name") && c.getProperty("Direction") == b.getProperty("Direction");
        })) {
          a.push(b);
        }

        return a;
      }, []);
      var html = list.reduce(function (a, b) {
        var color = bus_routes_colors.get(b.getProperty("Name"));
        color = "rgba(" + color + ")";
        var con = "";

        if (b.getProperty("Direction") == 1) {
          con += " <- ";
        } else {
          con += " -> ";
        }

        con += "<b style='display:inline-block;padding:3px;border-radius:1px;background:white;color: ".concat(color, "'>") + b.getProperty("Name") + "</b> " + b.getProperty("Destination");
        return a.concat([con]);
      }, []).join("<br>");
      var popup = {
        detail: true,
        content: html
        /*    marker: f */

      };
      app.tags.map.update({
        popup: popup
      });
    } else {// app.tags.map.update({ popup: false });
    }

    if (changed) $mn.isMap().data.revertStyle();
  }

  $mn.on('click', clickRoutes);
  $mn.on("feature/remove", function (feat) {
    if (feat.feature.getProperty("feature") == _feature) {
      if (feat.feature.getProperty("poly")) {
        feat.feature.getProperty("poly").setMap(null);
      }
    }
  });
  app.on("search/click/" + "busroutes", function (item) {
    route("map", {
      detail: _feature,
      map: {
        center: item.obj.data.location,
        zoom: 15
      },
      clear: true
    });
  });
  app.on("search/query", function (q, cb, register) {
    register(_feature, true);

    _lib.ajax.$get("/app/router/search.php?busroutes&q=" + q, function (data) {
      var results = [];
      var json = JSON.parse(data);
      if (json && Array.isArray(json.list)) json.list.forEach(function (item) {
        results.push({
          options: json.options,
          label: item.label + " " + item.values[0] + " (" + item.values[1] + ")",
          type: "Bus Routes",
          dataset: "busroutes",
          obj: item,
          image: _icon
        });
      });
      cb(results, _feature);
    });
  });
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    clickRoutes(e);
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      if (!feat.getProperty("color")) {
        var color = bus_routes_colors.get(feat.getProperty("Name"));
        color = "rgba(" + color + ")";
        var width = Math.round(Math.random() * 3 + 2);
        var zindex = 10 - width;
        var opacity = 0.8;
        feat.setProperty("width", width);
        feat.setProperty("zindex", zindex);
        feat.setProperty("opacity", opacity);
        feat.setProperty("color", color);
      } else {
        width = feat.getProperty("width");
        zindex = feat.getProperty("zindex");
        opacity = feat.getProperty("opacity");
        color = feat.getProperty("color");
      }

      if (atleastOne && !feat.getProperty("clicked")) {
        opacity = 0.5;
        width = 2;
        zindex = 1;
      } // console.log(opacity, atleastOne);


      riot.util.misc.extend(_style, {
        strokeColor: color,
        strokeOpacity: opacity,
        strokeWeight: width,
        zIndex: zindex //feat.getProperty("Status") == "Primary" ? 3 : 1

      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "capitalprojects";
  var _icon = "/assets/publica/sets/Find_Pin_Map.svg";
  var _groups = {
    "Arts & Culture": {
      t: "Arts",
      c: "#FF7F50"
    },
    "Corporate Capital": {
      t: "Corporate",
      c: "#DAA520"
    },
    "Flood Protection & Control Works": {
      t: "Floods",
      c: "#00008B"
    },
    "Heritage Protection": {
      t: "Heritage",
      c: "#D2691E"
    },
    "Housing": {
      t: "Housing",
      c: "#000000"
    },
    "Parks & Open Spaces": {
      t: "Parks",
      c: "#228B22"
    },
    "Parks, heritage and coastal environment": {
      t: "Coastal and Heritage",
      c: "#255B52"
    },
    "Parks, Heritage & Coastal Environment": {
      t: "Parks, Coastal and Heritage",
      c: "#255B52"
    },
    "Refuse Minimisation & Disposal": {
      t: "Rubbish",
      c: "#800000"
    },
    "Solid Waste & Resource Recovery": {
      t: "Rubbish",
      c: "#800000"
    },
    "Resilient Communities": {
      t: "Resillience",
      c: "	#FF00FF"
    },
    "Roads & Footpaths": {
      t: "Roads",
      c: "#FF8C00"
    },
    "Sewage Collection & Treatment": {
      t: "Sewage",
      c: "#20B2AA"
    },
    "Sport & Recreation": {
      t: "Recreation",
      c: "#FF6347"
    },
    "Stormwater Drainage": {
      t: "Stormwater",
      c: "#008080"
    },
    "Flood Protection and Control Works": {
      t: "Flood Protection",
      c: "#008080"
    },
    "Strategic Governance": {
      t: "Governance",
      c: "#EE82EE"
    },
    "Transport": {
      t: "Transport",
      c: "#F4A460"
    },
    "Water Supply": {
      t: "Water Supply",
      c: "#4169E1"
    },
    "Wastewater": {
      t: "Wastewater",
      c: "#5159D1"
    },
    "Other": {
      t: "Other",
      c: "#FFFFFF"
    }
  };

  var _boundsTT;

  var _legfilter = {
    legend: {
      list: []
    },
    filter: {
      show: false,
      options: Object.keys(_groups).reduce(function (r, a) {
        r.push({
          group: "group",
          label: _groups[a].t
        });
        return r;
      }, [])
    }
  };
  var _filterListGroups = [],
      _filterActive = false;
  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("Name"),
        desc: "",
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });

  _legfilter.filter.callBack = function (options) {
    if (options === false) {
      $mn.isMap().data.forEach(function (a) {
        if (a.getProperty('feature') == _feature) {
          a.setProperty('visible', true);
          $mn.isMap().data.overrideStyle(a, {
            visible: true
          });
        }
      });
      _filterListGroups = [];
      _filterActive = false;
    } else {
      var goodtypes = options.reduce(function (r, p) {
        if (p.checked && p.group == "group") r.push(p.label);
        return r;
      }, []);
      var badtypes = options.reduce(function (r, p) {
        if (!p.checked && p.group == "group") r.push(p.label);
        return r;
      }, []);
      _filterActive = true;
      _filterListGroups = goodtypes;
      $mn.isMap().data.forEach(function (a) {
        if (a.getProperty('feature') == _feature) {
          var visible = false;

          if (goodtypes.length > 0) {
            visible = goodtypes.some(function (b) {
              return _groups[a.getProperty('activity')].t == b;
            });
          } //feat.getProperty('activity')


          a.setProperty('visible', visible);
          $mn.isMap().data.overrideStyle(a, {
            visible: visible
          });
        }
      });
    }

    legendRefresh();
  };

  function legendRefresh() {
    clearTimeout(_boundsTT);

    if ($mn.layers.has(_feature)) {
      _boundsTT = setTimeout(function () {
        _legfilter.legend.list = Object.keys(_groups).filter(function (a) {
          return $mn.layers.getVisible().some(function (b) {
            return a == b.getProperty('activity');
          });
        }).reduce(function (r, c) {
          if (_groups[c]) {
            r.push({
              label: _groups[c].t,
              line: _groups[c].c
            });
          } else {
            r.push({
              label: _groups["Other"].t,
              line: _groups["Other"].c
            });
          }

          return r;
        }, []);
        app.maplegend.init({
          list: _legfilter.legend.list,
          filter: _legfilter.filter
        }).update();
        $mn.one('bounds/changed', legendRefresh);
      }, 500);
    }
  }

  $mn.on('layer/loaded/' + _feature, function (list) {
    legendRefresh();
    $mn.one('bounds/changed', legendRefresh);
    list.forEach(function (a) {
      if (typeof _groups[a.getProperty("activity")] == "undefined") {
        _groups[a.getProperty("activity")] = {
          t: a.getProperty("activity"),
          c: "#" + ('00000' + (Math.random() * (1 << 24) | 0).toString(16)).slice(-6)
        };
      }

      _groups[a.getProperty("activity")].count = 0;
    });
    list.forEach(function (a) {
      return _groups[a.getProperty("activity")].count = 1 + (_groups[a.getProperty("activity")].count || 0);
    });
    _legfilter.filter.options = Object.keys(_groups).reduce(function (r, a) {
      if (_groups[a].count) r.push({
        group: "group",
        label: _groups[a].t,
        value: "(".concat(_groups[a].count, ")")
      });
      return r;
    }, []);
  });
  /*function showDirectory(list) {
      app.alert.set({
          title: "Capital Projects",
          list: list.reduce((r, a) => {
              r.push({ title: a.getProperty("title"), feat: a });
              return r;
          }, []),
          collapsed: true
      });
  }
  app.on("map/data/" + _feature, showDirectory);*/

  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var details = [{
      svgIcon: "Rate",
      label: "Budget",
      value: f.getProperty("budget")
    }, {
      svgIcon: "Grade",
      label: "Phase",
      value: f.getProperty("phase")
    }];

    if (f.getProperty("starts_on").split(" ")[1] > 2000) {
      details.push({
        svgIcon: "Date",
        label: "Estimated start",
        value: f.getProperty("starts_on")
      });
    }

    ;

    if (f.getProperty("ends_on").split(" ")[1] > 2000) {
      details.push({
        svgIcon: "Date",
        label: "Estimated end",
        value: f.getProperty("ends_on")
      });
    }

    ;
    details.push({
      svgIcon: "Power",
      label: "Activity",
      value: f.getProperty("activity")
    });
    var popup = {
      detail: true,
      data: {
        title: f.getProperty("title"),
        sub: f.getProperty("comment"),
        details: details //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
    return;
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {}; //  url: "/assets/c/drinkingfountain-mapmarker.svg",

    if (feat.getProperty("feature") == _feature) {
      var _icon;

      if (_groups[feat.getProperty('activity')]) {
        _icon = '/assets/publica/scripts/Find_Pin.php?color=' + encodeURIComponent(_groups[feat.getProperty('activity')].c);
      } else {
        _icon = '/assets/publica/scripts/Find_Pin.php?color=' + encodeURIComponent(_groups["Other"].c);
        console.log("Missing " + feat.getProperty('activity'));
      }

      riot.util.misc.extend(_style, {
        icon: {
          //  url: "/assets/pointer/web-pointers-drinking-fountain-33.svg",
          url: _icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "consultations";
  var _icon = "assets/icons/black/book.png";
  app.on("search/click/" + "consultations", function (item) {
    var url = JSON.parse(item.obj.data.data);
    window.open("http://ccc.govt.nz" + url.URLValue, "ccc");
  });
  app.on("search/query", function (q, cb, register) {
    register(_feature, true);

    _lib.ajax.$get("/app/router/search.php?consultation&q=" + q, function (data) {
      var results = [];
      var json = JSON.parse(data);
      if (json && Array.isArray(json.list)) json.list.forEach(function (item) {
        results.push({
          options: json.options,
          label: item.label,
          type: "Consultations",
          dataset: "consultations",
          obj: item,
          image: _icon
        });
      });
      cb(results, _feature);
    });
  });
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var html = f.getProperty("Name");
    if (f.getProperty("ThumbnailURL") && f.getProperty("ThumbnailURL").length > 0) html += "<img height=50 class='detail-event-image' src='http://ccc.govt.nz" + f.getProperty("ThumbnailURL") + "'>";
    html += "<br>" + f.getProperty("CurrentStage");
    html += "<br>" + f.getProperty("Summary");
    html += "<br><a target=_blank href='http://ccc.govt.nz" + f.getProperty("URLValue") + "'>Details</a>";
    var detail = {
      name: f.getProperty("Name"),
      link: "http://ccc.govt.nz" + f.getProperty("URLValue"),
      info: [{
        label: "State",
        text: f.getProperty("CurrentStage")
      }, {
        label: "Details",
        text: f.getProperty("Summary")
      }]
    };

    if (f.getProperty("ThumbnailURL") && f.getProperty("ThumbnailURL").length > 0) {
      detail.image = "http://ccc.govt.nz" + f.getProperty("ThumbnailURL");
    }

    var data = {
      location: {
        lat: e.latLng.lat(),
        lng: e.latLng.lng()
      },
      detail: detail
    };
    var feat = f;
    var popup = {
      detail: true,
      data: {
        title: feat.getProperty("Name"),
        sub: f.getProperty("Summary"),
        details: [{
          svgIcon: "Grade",
          label: "Current Stage",
          value: f.getProperty("CurrentStage")
        }, {
          svgIcon: "Rate",
          label: "Details",
          html: "<a target=_blank href='http://ccc.govt.nz" + f.getProperty("URLValue") + "'>Details</a>"
        }]
      }
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          url: "/assets/publica/sets/Find_Pin_Location.svg",
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "earthquakes";
  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      return {
        //icon: _icon,
        name: a.getProperty("Name"),
        desc: a.getProperty("Magnitude"),
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Earthquake directory",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("Name"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var feat = f;
    var popup = {
      detail: true,
      data: {
        title: feat.getProperty("Name"),
        sub: "",
        details: [{
          svgIcon: "Magnitude",
          label: "magnitude",
          value: feat.getProperty("Magnitude")
        }, {
          svgIcon: "Depth",
          label: "depth",
          value: feat.getProperty("Depth"),
          unit: "m"
        }] //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          /*  path: google.maps.SymbolPath.CIRCLE,
           strokeColor: 'rgba(250, 0, 0, 0.9)',
           strokeOpacity: 0.8,
           strokeWeight: 2,
           fillColor: 'rgba(0, 0, 250, 0.75)',
           fillOpacity: 0.35,
           radius: 10,
           scale: feat.getProperty("Magnitude") * 3 */
          url: "/assets/publica/sets/Environment_Pin_Map.svg",
          scaledSize: app.conf.mapIconSize()
        }
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "ecocounter";
  var _feature_ped = "ecocounter-ped";
  var hiddenNames = ["Eco Display Sensor 2", "Eco Display Sensor 1", "Eco Display towards Antigua", "Eco Display towards Rolleston Ave", "Main Rd on-road", "Main Rd shared path", "Eco Display", "Be Counted 2018 Stock"];
  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature || parseInt(a.getProperty("count")) > 0 && a.getProperty("feature") == _feature_ped;
    }).map(function (a) {
      return {
        //icon: _icon,
        name: a.getProperty("name"),
        desc: a.getProperty("count"),
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });

  function showDirectory(list) {
    if (list[0].getProperty("feature") == _feature_ped) {
      var title = "Pedestrian counter directory";
    } else {
      var title = "Cycle counter directory";
    }

    app.alert.set({
      title: title,
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("name") + " - " + a.getProperty("count"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature_ped, function (data) {
    if (Array.isArray(data)) {
      showDirectory(data.filter(function (a) {
        return a.getProperty("count") > 0;
      }));
    }
  });
  app.on("map/data/" + _feature, function (data) {
    if (Array.isArray(data)) {
      showDirectory(data);
    }
  });
  app.on("map/feature/detail/" + _feature, showDetail);
  app.on("map/feature/detail/" + _feature_ped, showDetail);

  function showDetail(map, f, e) {
    var content = {};

    if (f.getProperty("name")) {
      content.name = f.getProperty("name");
    }

    if (f.getProperty("total")) {
      content.info = [{
        label: 'Total count for last week',
        text: f.getProperty("count")
      }];
    } else {
      content.info = [{
        label: 'Cycle count for last week',
        text: f.getProperty("count")
      }];
      var dir = "Counts only in one direction";

      if (f.getProperty("direction")) {
        if (f.getProperty("direction") == "both") {
          dir = "Counts both directions";
        }
      }
    }

    var popup = {
      tag: 'popup-ecocounter',
      content: {
        name: f.getProperty("name"),
        count: f.getProperty("count"),
        oid: f.getProperty("oid"),
        location: f.getGeometry().get(),
        direction: dir,
        feature: f.getProperty("feature")
      }
    };

    if (f.getProperty("installed_on")) {
      var ion = f.getProperty("installed_on");

      if (ion != "1970-01-01" && ion != "1900-01-01") {
        popup.content.installedOn = ion;
      }
    }

    app.tags.map.update({
      popup: popup
    });
  }

  ;

  var getStyle = function getStyle(feat) {
    var scale = Math.pow(feat.getProperty("count") / 10000, 0.25) * 30;
    var visible = hiddenNames.every(function (a) {
      return a != feat.getProperty("name");
    });

    if (feat.getGeometry().get().lat() == 0) {
      visible = false;
      feat.setGeometry($mn.defaultOptions.center);
      console.log(feat);
    }

    if (app.isDatasetActive("bike-tracks2")) {
      scale = 20;
      visible = visible && $mn.zoom() >= 14;
    }

    var text = feat.getProperty("count") == 0 ? "0" : feat.getProperty("count");

    if (feat.getProperty("total")) {
      text = "Total: " + text;
    }

    var newstyle = {
      icon: {
        path: google.maps.SymbolPath.CIRCLE,
        strokeColor: 'rgba(250, 0, 0, 0.9)',
        strokeOpacity: 0.8,
        strokeWeight: 2,
        fillColor: feat.getProperty("total") ? 'rgba(100, 250, 250, 1)' : feat.getProperty("direction") == "both" ? 'rgba(100, 100, 250, 1)' : 'rgba(100, 250, 100, 1)',
        fillOpacity: 0.6,
        radius: 10,
        scale: scale
      },
      label: {
        color: 'black',
        fontSize: '12px',
        fontWeight: 'bold',
        text: text || "0"
      },
      visible: visible && feat.getProperty("count") > 0
    };
    return newstyle;
  };

  $mn.one("map/idle", function () {
    $mn.isMap().addListener('zoom_changed', function () {
      var map = $mn.isMap();
      var zoom = $mn.zoom();
      /* if (zoom > 17 && $mn.lastZoom() > 17) return;
      else if (zoom < 13 && $mn.lastZoom() < 13) return;
      else if (!(zoom < 17 && $mn.lastZoom() > 13)) return;
      */

      setTimeout(function () {
        map.data.forEach(function (f) {
          if (f.getProperty("feature") == _feature) {
            map.data.overrideStyle(f, getStyle(f));
          }
        });
      }, 100);
    });
  });
  $mn.on("layer/loaded/" + _feature, function (list) {
    var _legend = {
      legend: {
        list: [],
        name: _feature
      }
    };

    _legend.legend.list.push({
      line: "rgba(100, 250, 250, 1)",
      label: "total counts"
    });

    _legend.legend.list.push({
      line: "rgba(100, 100, 250, 1)",
      label: "counts both directions"
    });

    _legend.legend.list.push({
      line: "rgba(100, 250, 100, 1)",
      label: "counts one direction"
    }); //app.tags.map.update(_legend);


    app.maplegend.init(_legend.legend).update(); //dontExtendTo
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature || feat.getProperty("feature") == _feature_ped) {
      // console.log(feat.getProperty("count"));
      var newstyle = getStyle(feat);
      /*$mn.isMap().data.forEach(a=>{
      if (a.getProperty("name")=="Be Counted 2018 Stock") {
         $mn.isMap().data.remove(a);
      }});*/

      riot.util.misc.extend(_style, newstyle);
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "events";
  var _icon = "assets/icons/black/events.png";
  app.on("search/click/" + "events", function (item) {
    route("events", {
      setFilters: {
        when: item.obj.time_from,
        cat: item.obj.catid
      }
    });
  });
  app.on("search/query", function (q, cb, register) {
    register(_feature, true);

    _lib.ajax.$get("/app/router/event.php?search=" + q, function (data) {
      var results = [];
      var json = JSON.parse(data);
      if (Array.isArray(json)) json.forEach(function (item) {
        results.push({
          options: json.options,
          label: item.name_short + " " + item.time_from,
          type: "Events",
          dataset: "events",
          obj: item,
          image: _icon
        });
      });
      cb(results, _feature);
    });
  });
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var newhtml = "<h3>" + f.getProperty("Name") + "</h3>";
    if (f.getProperty("image") && f.getProperty("image").length > 0) newhtml += "<img class='detail-event-image' src='" + f.getProperty("image") + "'>";
    newhtml += f.getProperty("location") + "<br>" + f.getProperty("address") + "<br>" + f.getProperty("date") + " " + f.getProperty("from") + "<br>" + f.getProperty("description");
    /* newhtml +=
         f.getProperty("Starts") +
         (f.getProperty("Ends") && f.getProperty("Ends") != "01/01/1970" ?
             " - " + f.getProperty("Ends") :
             "") +
         "<br>" +
         f.getProperty("Description") +
         //event.feature.getProperty("Notes") + "<br>" +
         (f.getProperty("Timeofday") ? "<br>" + f.getProperty("Timeofday") : "");*/

    var data = {
      location: {
        lat: e.latLng.lat(),
        lng: e.latLng.lng()
      },
      content: newhtml
    };
    var popup = {
      detail: true,
      content: newhtml,
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          url: "/assets/pointer/web-pointers-calendar.svg",
          scaledSize: new google.maps.Size(48, 32)
        }
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "evstations";
  var _icon = "/assets/publica/sets/Find_Pin_Map.svg"; //"/assets/c/drinkingfountain-mapmarker.svg";

  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("Name"),
        desc: "",
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });

  function showDirectory(list) {
    app.alert.set({
      title: "EV charging stations",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("Name"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var popup = {
      detail: true,
      data: {
        title: f.getProperty("Name"),
        sub: "",
        details: [{
          svgIcon: "Rate",
          label: "Charging cost",
          value: f.getProperty("Cost") == 1 ? "Yes" : "No"
        }, {
          svgIcon: "Power",
          label: "KW rated",
          value: f.getProperty("KWrated")
        }, {
          svgIcon: "Status",
          label: "Status",
          value: f.getProperty("Status")
        }, {
          label: "Connectors",
          value: f.getProperty("connectors").reduce(function (r, a) {
            return r.concat([a.connectorType]);
          }, []).join(", ")
        }] //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
    return;
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {}; //  url: "/assets/c/drinkingfountain-mapmarker.svg",

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          //  url: "/assets/pointer/web-pointers-drinking-fountain-33.svg",
          url: _icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "flights";
  var _icon = "assets/plane_bl.svg";
  app.on("search/click/" + "flights", function (item) {
    route("travel/flights", item);
  });
  app.on("search/query", function (q, cb, register) {
    register(_feature, true);

    _lib.ajax.$get("/app/router/search.php?flights&q=" + q, function (data) {
      var results = [];
      var json = JSON.parse(data);
      if (json && Array.isArray(json.list)) json.list.forEach(function (item) {
        results.push({
          options: json.options,
          label: item.label,
          type: "Flights",
          dataset: "flights",
          obj: item,
          image: _icon
        });
      });
      cb(results, _feature);
    });
  });
  app.on("list/filter/apply/" + _feature, function (d) {
    var showlist = d.filters.reduce(function (r, a) {
      return r.concat(a.list.filter(function (a) {
        return a.checked;
      }));
    }, []);
    d.list.forEach(function (a) {
      a.hide = !showlist.every(function (b) {
        return b.filter(a);
      });
    });
    d.finished();
  });
  app.on("list/filter-data/" + _feature, function (filterData, detail) {
    var list = [];
    detail.list.forEach(function (a) {
      list.some(function (b) {
        return b.name == a.label;
      }) || list.push({
        name: a.label,
        filter: function filter(b) {
          return a.label == b.label;
        }
      });
    });
    filterData[0] = {
      label: "Airports",
      name: "Airports",
      list: list
    };
  });
})(app, riot);

(function (app, riot) {
  var _feature = "freewifi";
  var _icon = "/assets/publica/sets/Find_Pin_Map.svg"; //"/assets/pointer/web-pointers-wifi.svg";

  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("Name"),
        desc: "",
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Free WIFI directory",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("Name"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var popup = {
      detail: true,
      data: {
        title: f.getProperty("Name"),
        sub: ""
      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
    return;
    var html = f.getProperty("Name");
    var data = {
      location: {
        lat: e.latLng.lat(),
        lng: e.latLng.lng()
      },
      detail: {
        name: html
      }
    };
    var popup = {
      detail: true,
      content: html,
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          url: _icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "kites";
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var sens = f.getProperty("Data");
    var detail = {
      name: f.getProperty("Name"),
      info: []
    };
    var text = f.getProperty("Name") + "<br>";

    for (var i in sens) {
      detail.info.push({
        label: i.split("_")[0],
        text: sens[i]
      });
      text += i.split("_")[0] + " : " + sens[i] + "<br>";
    }

    var data = {
      location: {
        lat: e.latLng.lat(),
        lng: e.latLng.lng()
      },
      detail: detail
    };
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          url: "/assets/pointer/web-pointers-weather.svg",
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

;

(function (app, riot) {
  var _feature = 'escooters';
  var _feature_timeline = 'limescooterline';
  var _feature_tripbin = 'limeapi-tripbins';
  var _feature_morning_clusters = 'escooters-morning-clusters';
  var _icon = "/assets/publica/sets/OnTheGo_Pin_Map.svg"; //'/assets/pointer/web-pointers-star.svg'

  var _poly;

  var _animInterval;

  var _heatmap;

  var _heatmapsByProvider = {};
  var _providers = {};

  var _timelapse_tag;

  var _colors = {
    "Lime": 'rgba(36, 208, 0, 1.0)',
    "Flamingo": 'rgba(251, 120, 165, 1.0)',
    "Jump": 'rgba(255, 0, 0, 1.0)'
  };
  var _tripbin_colors = [{
    color: 'rgba(240,230,140,%)',
    min: 3,
    max: 10
  }, {
    color: 'rgba(255,255,0,%)',
    min: 11,
    max: 100
  }, {
    color: 'rgba(255,165,0,%)',
    min: 101,
    max: 1000
  }, {
    color: 'rgba(255,0,0,%)',
    min: 1001,
    max: 10000
  }, {
    color: 'rgba(255,0,255,%)',
    min: 10001,
    max: 100000
  }, {
    color: 'rgba(0,255,0,%)',
    min: 100001,
    max: 1000000
  }, {
    color: 'rgba(0,0,255,%)',
    min: 1000001,
    max: 100000000
  }];
  var _filterList = [],
      _filterActive = false;
  app.on('map/feature/remove', function (map, f) {
    if (f.feature.getProperty('feature') == _feature_timeline) {
      if (_poly) {
        _poly.setMap(null);
      }

      _animInterval = clearTimeout(_animInterval);
    }
  }); //_map.trigger('layer/unloaded/' + layer);

  $mn.on("layer/unloaded/" + _feature_morning_clusters, function () {
    Object.keys(_providers).forEach(function (key) {
      var _heatmapsByProvider$k;

      (_heatmapsByProvider$k = _heatmapsByProvider[key]) === null || _heatmapsByProvider$k === void 0 ? void 0 : _heatmapsByProvider$k.setMap(null);
    }); //if (_heatmap) _heatmap.setMap(null)
  });
  $mn.on("layer/loaded/" + _feature_morning_clusters, function (list) {
    var opacity = 0.9;
    list.forEach(function (a) {
      var _a$getProperty, _providers$_a$getProp;

      (_providers$_a$getProp = _providers[_a$getProperty = a.getProperty("provider")]) !== null && _providers$_a$getProp !== void 0 ? _providers$_a$getProp : _providers[_a$getProperty] = [];

      _providers[a.getProperty("provider")].push(a);
    });
    Object.keys(_providers).forEach(function (key) {
      var y = _providers[key].map(function (a) {
        return a.getGeometry().get();
      });

      _heatmapsByProvider[key] = new google.maps.visualization.HeatmapLayer({
        data: y
      });

      _heatmapsByProvider[key].setOptions({
        radius: 15,
        opacity: 0.95,
        gradient: ["rgba(0,0,0,0.0)", _colors[key], _colors[key].replace('1.0', opacity)],
        dissipating: true,
        maxIntensity: 5
      });

      _heatmapsByProvider[key].setMap($mn.isMap());

      opacity /= 2;
    });
    var _legend = {
      legend: {
        list: [{
          line: '#24d000',
          label: 'Lime'
        }, {
          line: '#fb78a5',
          label: "Flamingo"
        }, {
          line: 'rgb(255 0 0)',
          label: "Jump"
        }]
      }
    };
    app.maplegend.init(_legend.legend).update();
    app.alert.set("Estimated starting locations of scooters in the morning after charging / maintanance. Based on last 3 days.");
    /*     var y = list.map(a => {return a.getGeometry().get()})
        _heatmap = new google.maps.visualization.HeatmapLayer({
            data: y
        });
        _heatmap.setOptions({ radius: 15, opacity: 1, gradient: ["rgba(0,0,0,0.0)","rgba(0,0,255,1)", "rgb(0,0,255)"],dissipating:true,maxIntensity:5})
        _heatmap.setMap($mn.isMap()) */
    // console.log(_heatmap);
  });
  $mn.on('layer/loaded/' + _feature_tripbin, function (list) {
    var _legend = {
      legend: {
        list: []
      }
    };

    _tripbin_colors.forEach(function (a) {
      var start = a.color.replace('%', '0.25');
      var end = a.color.replace('%', '1');

      _legend.legend.list.push({
        line: "linear-gradient(to right, ".concat(start, ", ").concat(end, ")"),
        label: "".concat(a.min, " - ").concat(a.max)
      });
    }); //app.tags.map.update(_legend);


    app.maplegend.init(_legend.legend).update();

    _lib.ajax.$get("/app/router/lime.php?timeline", function (data) {
      var json = JSON.parse(data);
      var acc = {};
      Object.keys(json).forEach(function (a, i) {
        json[a] = acc = app.extend(acc, json[a]);
      });
      _timelapse_tag = document.createElement("timeline-map-lime");
      app.tags.map.root.appendChild(_timelapse_tag);
      riot.mount(_timelapse_tag, {
        data: json
      });
    });
  });
  app.on("map/timelapse/check/" + _feature_tripbin, function (l) {
    l.hide = false;
  });
  app.on("dataset/change", function () {
    var timelapse = {
      hide: true
    };
    $mn.layers.eachLayer(function (a) {
      app.trigger("map/timelapse/check/" + a, timelapse);
    });

    if (timelapse.hide && _timelapse_tag) {
      _timelapse_tag.parentNode.removeChild(_timelapse_tag);

      _timelapse_tag = null;
    }
  });
  $mn.on('layer/loaded/' + _feature_timeline, function (list) {
    var arr = [];
    list.forEach(function (a) {
      arr.push(a.getGeometry().get());
    });
    var poly = _poly = new google.maps.Polyline({
      path: arr,
      map: $mn.isMap(),
      strokeColor: 'blue',
      strokeOpacity: 0.7,
      strokeWeight: 3,
      icons: [{
        icon: {
          path: 'm 7.2865553,1.3491665 c -0.1915252,0.045472 -0.5243322,0.2059343 -0.572237,0.2753587 -0.1053526,0.1484859 0.014409,0.3807117 0.1962972,0.3807117 0.02152,0 0.126966,-0.035929 0.2322255,-0.081401 0.4046645,-0.1747775 0.6153705,-0.1675731 0.7207232,0.023952 0.035928,0.067085 0.1891866,0.6992033 0.4717495,1.9634392 0.229887,1.0248058 0.4286167,1.9107628 0.440593,1.9657784 l 0.023952,0.1005813 -0.1772102,0.083833 C 8.3927622,6.1692065 8.253913,6.2673552 8.0647272,6.4445652 7.7319202,6.7630569 7.5642531,7.0838877 7.4517892,7.6130853 l -0.011976,0.066992 H 6.3287414 5.2201019 L 5.1889454,7.529252 C 4.9639244,6.3727081 3.8073801,5.6400089 2.6604735,5.9321155 2.2533765,6.0374686 1.7266117,6.3774799 1.6667305,6.5737771 c -0.033496,0.1173291 0.014409,0.2251148 0.1268729,0.282563 0.1077859,0.055109 0.1891865,0.028818 0.3688293,-0.12444 0.5075846,-0.4309555 1.2499206,-0.4908364 1.8221576,-0.1484859 0.3016505,0.1796427 0.572237,0.5267649 0.675251,0.8667763 0.069424,0.2250213 0.069424,0.2298866 -0.050244,0.2298866 H 4.5066771 L 4.4635442,7.529252 C 4.3988918,7.3113416 4.2911059,7.1389968 4.1115564,6.959354 3.8529462,6.703176 3.5488632,6.5786424 3.1801278,6.5786424 c -0.3831444,0 -0.675251,0.1197618 -0.9481769,0.3951205 -0.2754524,0.2729261 -0.3952147,0.5602609 -0.3952147,0.9409726 0,0.3879157 0.1197623,0.6776838 0.3974601,0.9553815 0.4215053,0.4190728 1.0201276,0.5100165 1.5659793,0.23943 C 4.1042587,8.9587221 4.384389,8.6139387 4.4729941,8.273834 l 0.031157,-0.1148964 h 1.6306323 c 1.5060989,0 1.633065,-0.00477 1.6785372,-0.043133 0.071857,-0.057448 0.1053527,-0.131738 0.1053527,-0.2274539 0,-0.3400114 0.1724383,-0.7590843 0.4238446,-1.0224668 C 8.4957755,6.70065 8.7447493,6.5234398 8.8597397,6.4947157 c 0.052677,-0.014409 0.059881,-0.0072 0.074289,0.086172 0.00954,0.055016 0.011976,0.1005812 0.00954,0.1029204 C 8.4431928,6.8897425 8.1007488,7.4595469 8.1414491,8.0174687 8.1678344,8.3430711 8.306683,8.6448148 8.5413419,8.874701 8.9555495,9.2817981 9.5948721,9.3775138 10.109661,9.1093598 10.423287,8.9465586 10.710622,8.5778231 10.794455,8.2306072 10.844793,8.0246731 10.832816,7.7133859 10.768164,7.5122234 10.600591,6.9878911 10.06896,6.5783617 9.558943,6.5783617 H 9.4344095 L 9.4104574,6.4705761 9.3865047,6.3627904 h 0.1962971 c 0.186754,0 0.2035016,-0.00477 0.2730198,-0.069424 0.059881,-0.057448 0.074196,-0.088605 0.074196,-0.1700056 0,-0.1963908 -0.1772102,-0.2849023 -0.5243322,-0.2609499 C 9.2835846,5.8719539 9.281152,5.8719539 9.2596319,5.7882141 9.2476562,5.7427421 9.0489265,4.8520133 8.8167003,3.8127986 8.3545877,1.7320301 8.3329743,1.6673775 8.1294728,1.4926001 7.9282173,1.3204424 7.6217017,1.2677659 7.2865553,1.3491665 Z M 3.5224779,7.1365642 c 0.069425,0.033496 0.1724383,0.1005812 0.2298869,0.1508251 0.098148,0.088605 0.23943,0.3016501 0.23943,0.3615311 0,0.047905 -0.5938504,0.043133 -0.6847942,-0.00477 -0.090944,-0.047905 -0.1724383,-0.045472 -0.2705872,0.0072 -0.091038,0.047905 -0.1700057,0.1747774 -0.1700057,0.2681542 0,0.098149 0.081401,0.2202496 0.1795495,0.2730195 0.081401,0.0407 0.1005808,0.043133 0.1891859,0.014409 0.055109,-0.016748 0.2442019,-0.035928 0.4286166,-0.0407 l 0.332807,-0.00954 -0.016748,0.055016 C 3.9199379,8.4128697 3.7092319,8.6283477 3.4913214,8.7120869 3.2901591,8.7911489 3.0172326,8.7887164 2.8375898,8.7048825 2.6484039,8.6162781 2.497579,8.4702244 2.404202,8.2811317 2.3347771,8.13985 2.3275733,8.1015826 2.3275733,7.9196007 c 0,-0.1675731 0.011976,-0.2274539 0.064652,-0.3375787 C 2.5958212,7.1413358 3.0986332,6.942606 3.5224779,7.136564 Z m 6.3237066,0.014315 c 0.1772105,0.081401 0.3256025,0.2274539 0.4118685,0.404664 0.05988,0.1196683 0.06699,0.1628013 0.06699,0.3639638 0,0.2753587 -0.04547,0.3902551 -0.227454,0.5843069 C 9.882113,8.7337003 9.5803692,8.8223054 9.2834907,8.748016 8.9027796,8.6498671 8.6633489,8.3625324 8.6417362,7.9793882 8.6297598,7.7543669 8.6561444,7.6418095 8.7614978,7.4645993 8.8333546,7.3472702 9.0344236,7.1605166 9.0608089,7.186808 c 0.033496,0.033496 0.1293055,0.5507174 0.1293055,0.691999 -0.00234,0.1555968 0,0.167573 0.076629,0.2442954 0.2633827,0.263382 0.6632746,-0.055109 0.4668843,-0.3711681 -0.0407,-0.064653 -0.1844147,-0.5889851 -0.186754,-0.6752511 0,-0.031157 0.1508249,0.0072 0.2993108,0.074196 z',
          scale: 2,
          strokeColor: 'red',
          rotation: 270,
          anchor: new google.maps.Point(10, 10)
        },
        offset: '0%'
      }]
    });
    var count = 0;
    var line = poly;
    _animInterval = window.setInterval(function () {
      count = (count + 1) % 600;
      var icons = line.get('icons');
      icons[0].offset = count / 6 + '%';
      line.set('icons', icons);
    }, 50);
    var _legend = {
      legend: {
        list: [{
          line: '',
          label: 'Shows last 20 trips'
        }, {
          line: '',
          label: "This scooter's trips: " + list[0].getProperty('trips')
        }]
      }
    };
    app.maplegend.init(_legend.legend).update(); //app.tags.map.update(_legend)
  });
  $mn.on('layer/loaded/' + _feature, function (list) {
    var _legend = {
      legend: {
        list: [{
          line: '#24d000',
          label: 'Lime'
        }, {
          line: '#fb78a5',
          label: "Flamingo"
        }, {
          line: 'rgb(255 0 0)',
          label: "Jump"
        }],
        filter: {
          show: false,
          options: [{
            label: 'Lime',
            checked: true,
            "default": true
          }, {
            label: 'Flamingo',
            checked: true,
            "default": true
          }, {
            label: 'Jump',
            checked: true,
            "default": true
          }],
          callBack: function callBack(options) {
            if (options === false) {
              $mn.isMap().data.forEach(function (a) {
                if (a.getProperty('feature') == _feature) {
                  a.setProperty('visible', true);
                  $mn.isMap().data.overrideStyle(a, {
                    visible: true
                  });
                }
              });
              _filterList = [];
              _filterActive = false;
            } else {
              var goodtypes = options.reduce(function (r, p) {
                if (p.checked) r.push(p.label);
                return r;
              }, []);
              /*     var badtypes = options.reduce((r, p) => {
                  if (!p.checked) r.push(p.label)
                  return r
              }, [])
              */

              _filterActive = true;
              _filterList = goodtypes;
              $mn.isMap().data.forEach(function (a) {
                if (a.getProperty('feature') == _feature) {
                  var visible = false;

                  if (goodtypes.length > 0) {
                    visible = goodtypes.some(function (b) {
                      return a.getProperty('provider') == b;
                    });
                  }

                  a.setProperty('visible', visible);
                  $mn.isMap().data.overrideStyle(a, {
                    visible: visible
                  });
                }
              });
            }
          }
        }
      }
    };
    app.maplegend.init(_legend.legend).update(); // app.tags.map.update(_legend)
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Scooter directory",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("provider") + ' at battery charge ' + a.getProperty("battery") + '%',
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on('map/features/list/callback', function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty('feature') == _feature;
    }).map(function (a) {
      return {
        // icon: _icon,
        name: a.getProperty("battery") + "%",
        //Math.round(100 * a.getProperty('meter_range') / 37000) + '%',
        desc: a.getProperty('rate_plan'),
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });
  app.on('map/feature/detail/' + _feature_timeline, function (map, f, e) {
    var charge = f.getProperty("battery"); // Math.round(100 * f.getProperty('meter_range') / 37000)

    var html = '<br>The vehicle had ' + charge + ' % battery charge on ' + f.getProperty('last_activity_at');
    var popup = {
      detail: true,
      content: html,
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on('map/feature/detail/' + _feature, function (map, f, e) {
    /*    var html = "";
       html += f.getProperty("api") == "limeapi_status" ? "Lime" : "Beam";
       html += '<br>Battery charge: ' + f.getProperty("battery") + '%<br>'
       var feat = f; */
    var title = f.getProperty("provider") + " at " + f.getProperty("battery") + '% battery charge';

    if (f.getProperty("vehicle_id")) {
      title = f.getProperty("provider") + " (#" + f.getProperty("vehicle_id") + ") at " + f.getProperty("battery") + '% battery charge';
    }

    var popup = {
      detail: true,
      data: {
        title: title,
        sub: " Last activity at:" + f.getProperty('last_activity_at') //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on('map/feature/detail/' + _feature_tripbin, function (map, f, e) {
    var html = 'Number of trips at this location : ' + f.getProperty('count'); // html += "<"

    var popup = {
      detail: true,
      data: {
        title: html
      }
    };
    app.tags.map.update({
      popup: popup
    });
  });

  _lib.getLimeColor = function (c) {
    var color = _tripbin_colors[0].color;
    var opacity = c / (12.5 * 1);

    if (c > 10) {
      color = _tripbin_colors[1].color;
      opacity = c / (12.5 * 10);
    }

    if (c > 100) {
      color = _tripbin_colors[2].color;
      opacity = c / (12.5 * 100);
    }

    if (c > 1000) {
      color = _tripbin_colors[3].color;
      opacity = c / (12.5 * 1000);
    }

    if (c > 10000) {
      color = _tripbin_colors[4].color;
      opacity = c / (12.5 * 10000);
    }

    if (c > 100000) {
      color = _tripbin_colors[5].color;
      opacity = c / (12.5 * 100000);
      opacity += 0.25;
    }

    opacity += 0.25;
    opacity = Math.max(opacity, 0.25);
    opacity = Math.round(opacity * 10) / 10;
    color = color.replace("%", opacity);
    return color;
  };

  app.on('map/feature/style', function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty('feature') == _feature_morning_clusters) {
      _style = {
        visible: false
      };
    }

    if (feat.getProperty('feature') == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          url: _icon.replace(".svg", "_".concat(feat.getProperty("provider"), ".svg")),
          scaledSize: app.conf.mapIconSize()
        },
        title: feat.getProperty("provider"),
        strokeColor: '#3b69b2'
      });
    }

    if (feat.getProperty('feature') == _feature_timeline) {
      var scale = feat.getProperty("battery"); //Math.pow(feat.getProperty('meter_range') / 10000, 0.25) * 10

      riot.util.misc.extend(_style, {
        icon: {
          path: 'M -4.5,-1.3 -4.5,1.3 4.5,1.3 4.5,-1.3 z',
          strokeColor: 'rgba(250, 0, 0, 0.9)',
          strokeOpacity: 0.8,
          strokeWeight: 1,
          fillColor: 'rgba(255, 255, 255, 0.95)',
          fillOpacity: 0.65,
          radius: 10,
          scale: 10
        },
        label: {
          color: 'black',
          fontSize: '12px',
          fontWeight: 'bold',
          text: feat.getProperty('last_activity_at')
        },
        strokeColor: '#3b69b2'
      });
    }

    if (feat.getProperty('feature') == _feature_tripbin) {
      var c = parseInt(feat.getProperty('count'));

      var color = _lib.getLimeColor(c);

      riot.util.misc.extend(_style, {
        visible: c > 2,
        strokeWeight: 1,
        strokeColor: 'rgba(255, 255, 255, 0.5)',
        fillColor: color,
        fillOpacity: 1
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "mtb-tracks";
  var _page = "mtbtrackstatus";
  var _icon = "assets/icons/black/mountain-bike.png";

  function showDirectory(list) {
    app.alert.set({
      title: "MTB tracks directory",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("Name"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/data/" + _page, showDirectory);
  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature || a.getProperty("feature") == _page;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("Name"),
        desc: a.getProperty("Status"),
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });
  app.on("detail/click/" + _page, function (item) {
    var popup = {
      detail: true,
      data: {
        title: feat.getProperty("Name"),
        sub: feat.getProperty("Status"),
        details: [{
          svgIcon: "Grade",
          label: "grade",
          value: feat.getProperty("Grade")
        }, {
          svgIcon: "Distance",
          label: "length",
          value: feat.getProperty("Length")
        }, {
          svgIcon: "Gradient",
          label: "gradient",
          value: feat.getProperty("Gradient")
        }, {
          svgIcon: "Flag",
          label: "ridden today",
          value: feat.getProperty("strava_day")
        }, {
          svgIcon: "Flag",
          label: "times ridden",
          value: feat.getProperty("strava_all")
        }] //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("search/click/" + "mtbtracks", function (item) {
    route("play/mtbtrackstatus", item);
  });
  app.on("search/query", function (q, cb, register) {
    register(_feature, true);

    _lib.ajax.$get("/app/router/search.php?mtbtracks&q=" + q, function (data) {
      var results = [];
      var json = JSON.parse(data);
      if (json && Array.isArray(json.list)) json.list.forEach(function (item) {
        results.push({
          options: json.options,
          label: item.label,
          type: "MTB Tracks",
          dataset: "mtbtracks",
          obj: item,
          image: _icon
        });
      });
      cb(results, _feature);
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature || feat.getProperty("feature") == _page) {
      var zIndex = 5;

      if (feat.getGeometry() && feat.getGeometry().getType() == "Polygon") {
        zIndex = 0;
      }

      var color = "blue";

      switch (feat.getProperty("Status")) {
        case "Closed":
        case "closed":
        case "Avoid":
        case "avoid":
          color = "orange";
          break;

        case "Open":
        case "open":
          color = "green";
          break;

        default:
          color = "blue";
      }

      riot.util.misc.extend(_style, {
        strokeColor: color,
        strokeWeight: 4,
        strokeOpacity: 0.8,
        zIndex: zIndex
      });
    }

    riot.util.misc.extend(style, _style);
  });

  var _mapDetail = function _mapDetail(map, f, e) {
    var feat = f;
    var popup = {
      detail: true,
      data: {
        title: feat.getProperty("Name"),
        sub: feat.getProperty("Status"),
        details: [{
          svgIcon: "Grade",
          label: "grade",
          value: feat.getProperty("Grade")
        }, {
          svgIcon: "Distance",
          label: "length",
          value: feat.getProperty("Length")
        }, {
          svgIcon: "Gradient",
          label: "gradient",
          value: feat.getProperty("strava_avg_grade")
        }, {
          svgIcon: "Flag",
          label: "ridden today",
          value: feat.getProperty("strava_day")
        }, {
          svgIcon: "Flag",
          label: "times ridden",
          value: feat.getProperty("strava_all")
        }] //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
  };

  app.on("map/feature/detail/" + _feature, _mapDetail);
  app.on("map/feature/detail/" + _page, _mapDetail);
})(app, riot);

(function (app, riot) {
  var _feature = "news";
  var _icon = "assets/icons/black/book.png";
  app.on("search/click/" + "news", function (item) {
    window.open(item.obj.data.link, "ccc");
  });
  app.on("search/query", function (q, cb, register) {
    register(_feature, true);

    _lib.ajax.$get("/app/router/search.php?news&q=" + q, function (data) {
      var results = [];
      var json = JSON.parse(data);
      if (json && Array.isArray(json.list)) json.list.forEach(function (item) {
        results.push({
          options: json.options,
          label: item.values[0],
          type: "News",
          dataset: "news",
          obj: item,
          image: _icon
        });
      });
      cb(results, _feature);
    });
  });
})(app, riot);

(function (app, riot) {
  var _feature = "parking";
  var _icon = "assets/icons/black/parking.png";
  var _legend = {
    legend: {
      list: [{
        line: "rgb(5,104,57)",
        label: "P60"
      }, {
        line: "rgb(100,33,101)",
        label: "P120"
      }, {
        line: "rgb(255,147,38)",
        label: "Unrestricted"
      }]
    }
  };
  var fil = {
    "motorcycle": function motorcycle(d) {
      return !d || !d.properties || !d.properties.RestrictedByUseCode || d.properties.RestrictedByUseCode != "MC";
    },
    "mobility": function mobility(d) {
      return !d || !d.properties || !d.properties.RestrictedByUseCode || d.properties.RestrictedByUseCode != "DP";
    },
    "120": function _(d) {
      return !d || !d.properties || !d.properties.RestrictedByDuration || d.properties.RestrictedByDuration != "120";
    },
    "60": function _(d) {
      return !d || !d.properties || !d.properties.RestrictedByDuration || d.properties.RestrictedByDuration != "60";
    },
    "30": function _(d) {
      return !d || !d.properties || !d.properties.RestrictedByDuration || d.properties.RestrictedByDuration != "30";
    },
    "10": function _(d) {
      return !d || !d.properties || !d.properties.RestrictedByDuration || d.properties.RestrictedByDuration != "10";
    },
    "5": function _(d) {
      return !d || !d.properties || !d.properties.RestrictedByDuration || d.properties.RestrictedByDuration != "5";
    },
    "onstreet": function onstreet(d) {
      return !d || !d.geometry || !d.geometry.type || d.geometry.type != "LineString";
    },
    "building": function building(d) {
      return !fil.motorcycle(d) && !fil.mobility(d) && !fil.onstreet(d);
    },
    "all": function all(d) {
      return false;
    }
  };
  app.on("search/click/" + _feature, function (item) {
    route("travel/parking/" + item.obj.data.id);
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Parking directory",
      list: list.reduce(function (r, a) {
        if (!a.getProperty("hidden")) {
          r.push({
            title: a.getProperty("popup"),
            feat: a
          });
        }

        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("list/filter/apply/" + _feature, function (d) {
    var showlist = d.filters.reduce(function (r, a) {
      return r.concat(a.list.filter(function (a) {
        return a.checked;
      }));
    }, []);
    d.list.forEach(function (a) {
      a.hide = !showlist.every(function (b) {
        return b.filter(a);
      });
    });
    d.finished();
  });
  app.on("list/click/" + _feature, function (item) {
    route("travel/parking/" + item.data.id);
  });
  app.on("detail/click/" + _feature, function (item) {
    route("travel/parking/" + item.item.data.id);
  });
  app.on("map/filter/" + _feature, function (filter) {
    $mn.layers.deactivateFeature();
    $mn.isMap().data.revertStyle();
    $mn.isMap().data.forEach(function (f) {
      var d = f.getProperty("json");

      if (d.properties) {
        if (fil[filter](d)) {
          f.setProperty("hidden", true);
          $mn.isMap().data.overrideStyle(f, {
            visible: false
          });
        } else {
          f.setProperty("hidden", false);
        }
      } else f.toGeoJson(function (d) {
        if (fil[filter](d)) {
          f.setProperty("hidden", true);
          $mn.isMap().data.overrideStyle(f, {
            visible: false
          });
        } else {
          f.setProperty("hidden", false);
        }
      });
    });

    if (filter != "all" && filter != "onstreet") {
      //app.tags.map.update({ legend: null })
      app.maplegend.reset().update();
    } else {
      //app.tags.map.update(_legend)
      app.maplegend.init(_legend.legend).update();
    }

    showDirectory($mn.layers.list["parking"]);
  });
  app.on("list/filter-data/" + _feature, function (filterData) {
    filterData[0] = {
      label: "Parking types",
      name: "Parking types",
      list: [{
        name: "On-street parking",
        filter: function filter(a) {
          return Object.byString(a, "data.data.geometry.type") == "LineString";
        }
      }, {
        name: "Off-street parking",
        filter: function filter(a) {
          return Object.byString(a, "data.data.geometry.type") != "LineString";
        }
      }, {
        name: "Mobility parking",
        filter: function filter(a) {
          return Object.byString(a, "data.data.properties.type") == "Mobility Off-Street" || Object.byString(a, "data.data.properties.RestrictedByUse") == "Disabled parking";
        }
      }, {
        name: "Motorcycle parking",
        filter: function filter(a) {
          return Object.byString(a, "data.data.properties.RestrictedByUse") == "Motorcycle parking";
        }
      }, //{ name: "Car park building" },
      {
        name: "Loading zone",
        filter: function filter(a) {
          return Object.byString(a, "data.data.properties.RestrictedByUse") == "Loading bay";
        }
      }, {
        name: "60 minute parking",
        filter: function filter(a) {
          return Object.byString(a, "data.data.properties.RestrictedByDurationCode") == "P60";
        }
      }, {
        name: "120 minute parking",
        filter: function filter(a) {
          return Object.byString(a, "data.data.properties.RestrictedByDurationCode") == "P120";
        }
      } //{ name: "All day parking" }
      ]
    };
    filterData[1] = {
      label: "Cost",
      name: "Cost",
      list: [{
        name: "Free",
        filter: function filter(a) {
          return Object.byString(a, "data.data.properties.Revenue") == "Not metered";
        }
      }, {
        name: "< $1 per hour",
        filter: function filter(a) {
          return Object.byString(a, "data.data.properties.ParkingHourlyRate") <= 1;
        }
      }, {
        name: "< $2 per hour",
        filter: function filter(a) {
          return Object.byString(a, "data.data.properties.ParkingHourlyRate") <= 2;
        }
      }, {
        name: "< $3 per hour",
        filter: function filter(a) {
          return Object.byString(a, "data.data.properties.ParkingHourlyRate") <= 3;
        }
      }, {
        name: "< $4 per hour",
        filter: function filter(a) {
          return Object.byString(a, "data.data.properties.ParkingHourlyRate") <= 4;
        }
      }, {
        name: "day rate",
        filter: function filter(a) {
          return Object.byString(a, "data.data.properties.ParkingDailyRate") > 0;
        }
      }]
    };
  });
  app.on("list/update/" + _feature, function (list, updCb) {
    var updateDistance = function updateDistance() {
      list.forEach(function (a) {
        var lat = 0,
            lng = 0;

        if (a.data.data.Location) {
          var x = a.data.data.Location.split(",");
          lat = x[0];
          lng = x[1];
        } else if (a.data.data.loc) {
          a.data.data.loc = a.data.data.loc.replace("[", "");
          a.data.data.loc = a.data.data.loc.replace("]", "");

          var _x = a.data.data.loc.split(",");

          lat = _x[0];
          lng = _x[1];
        } else if (a.data.data.geometry) {
          if (a.data.data.geometry.type == "Point") {
            lat = a.data.data.geometry.coordinates[1];
            lng = a.data.data.geometry.coordinates[0];
          } else if (a.data.data.geometry.type == "LineString") {
            lat = a.data.data.geometry.coordinates[0][1];
            lng = a.data.data.geometry.coordinates[0][0];
          } else if (a.data.data.geometry.type == "GeometryCollection") {
            lat = a.data.data.geometry.geometries[0].coordinates[0][1];
            lng = a.data.data.geometry.geometries[0].coordinates[0][0];
          } else {
            var _x2 = _maps.GeoJSON(a.data.data.geometry, {}, true)[0];

            lat = _x2.lat();
            lng = _x2.lng();
          }
        } else {// console.log(a.data.data);
        }

        if (app.lastPosition) {
          a.distance = _maps.distance(lat, lng, app.lastPosition.lat, app.lastPosition.lng);

          if (isNaN(a.distance)) {
            console.log(a.data.data, lat, lng);
          }
        } else {
          a.distance = false;
        }

        a.icon = "assets/icons/black/parking.png";
        if (a.distance) a.note = _maps.distanceRoundFormat(a.distance);
        a.style = {
          "background-image": "url(".concat(a.icon, ")")
        };
      });
      list.sort(function (a, b) {
        return a.distance < b.distance ? -1 : 1;
      });
    };

    if (app.lastPosition) {
      updateDistance();
    } else {
      list.forEach(function (a) {
        a.icon = "assets/icons/black/parking.png";
        a.style = {
          "background-image": "url(".concat(a.icon, ")")
        };
      });
      app.one("geolocation/found", function () {
        updateDistance();
        updCb();
      });
    }
  });
  app.on("search/query", function (q, cb, register) {
    register(_feature, true);

    _lib.ajax.$get("/app/router/search.php?parking&q=" + q, function (data) {
      var results = [];
      var json = JSON.parse(data);
      if (json && Array.isArray(json.list)) json.list.forEach(function (item) {
        results.push({
          options: json.options,
          label: item.label,
          type: "Parking",
          dataset: "parking",
          obj: item,
          image: _icon
        });
      });
      cb(results, _feature);
    });
  });

  var showDetail2 = function showDetail2(feat) {
    var html = "";
    html += "<strong>" + feat.getProperty("label") + "</strong><br>";
    if (feat.getProperty("free")) html += "Free parks: " + feat.getProperty("free") + "<br>";
    if (feat.getProperty("occupied")) html += "Occupied parks: " + feat.getProperty("occupied") + "<br>";
    if (feat.getProperty("street") && feat.getProperty("label") != feat.getProperty("street")) html += "Address: " + feat.getProperty("street") + "<br>";
    if (feat.getProperty("type") && feat.getProperty("type") != "Unrestricted") html += "Type: " + feat.getProperty("type") + "<br>";
    if (feat.getProperty("maxlength")) html += "Parking duration: " + feat.getProperty("maxlength") + "<br>";

    if (feat.getProperty("revenue")) {
      if (feat.getProperty("revenue") == "Not metered") {
        html += "Payment: free<br>";
      } else {
        html += "Payment: " + feat.getProperty("revenue") + "<br>";
      }
    }

    if (feat.getProperty("desc")) html += "" + feat.getProperty("desc") + "<br>";

    if (feat.getProperty("rates")) {
      if (feat.getProperty("rates").daily && feat.getProperty("rates").daily != "Not applicable") html += "Daily rate: $" + feat.getProperty("rates").daily + "<br>";
      if (feat.getProperty("rates").hourly && feat.getProperty("rates").hourly != "Not applicable") html += "Hourly rate: $" + feat.getProperty("rates").hourly + "<br>";
      if (feat.getProperty("rates").when) html += "Meter operational: " + feat.getProperty("rates").when + "<br>";
    } // var feat = f;


    if (feat.getProperty("json")) {
      if (feat.getProperty("json").properties) {
        console.log("Zone:", feat.getProperty("json").properties.ParkingZoneID);
      }
    }

    var popup = {
      detail: true,
      data: {
        title: feat.getProperty("label"),
        sub: feat.getProperty("street"),
        details: [{
          svgIcon: "ParksFree",
          label: "parks free",
          value: feat.getProperty("free")
        }, {
          svgIcon: "Car",
          label: "Type",
          value: feat.getProperty("Type")
        }, {
          svgIcon: "Duration",
          label: "duration",
          value: feat.getProperty("maxlength")
        }, {
          svgIcon: "Rate",
          label: "Payment",
          value: feat.getProperty("revenue")
        }, {
          label: "Description",
          value: feat.getProperty("desc")
        }, {
          svgIcon: "Rate",
          label: "Daily rate",
          value: "$" + feat.getProperty("rates").daily
        }, {
          svgIcon: "Rate",
          label: "Hourly rate",
          value: "$" + feat.getProperty("rates").hourly
        }] //content: html

      } // marker: feat

    };
    return popup;
    return html;
  };

  var showDetail = function showDetail(map, feat) {
    var featprops = ["free", "occupied", "Configuration", "RestrictedByUse", "RestrictedByUseCode", "RestrictedByDurationCode", "RestrictedByDurationDescription", "RestrictedByDuration", "Revenue", "RestrictedByTimeOfDay", "type", "spaces", "HoursOfOperation", "ParkingHourlyRate", "MeterHoursOfOperation", "address", "hourlyrate", "alldayrate", "timelimit", "nightrate", "monthly", "metered", "PleaseNote", "Access",
    /**************PHills********/
    "Type", "Status",
    /***********Wilson***********/
    "DisplayAddress", "General", "Instructions", "Phone", "HeightRestriction"];
    var html = feat.getProperty("Name") ? feat.getProperty("Name") : feat.getProperty("Label");

    for (var i = 0; i < featprops.length; i++) {
      if (feat.getProperty(featprops[i])) {
        html += "<br>" + featprops[i] + ": " + feat.getProperty(featprops[i]);
      }
    }

    if (feat.getProperty("RateList")) {
      var ratelist = feat.getProperty("RateList");

      for (i = 0; i < ratelist.length; i++) {
        html += "<br>" + ratelist[i].Name;
        var carrate = ratelist[i].CarParkRateList;

        if (carrate.length > 0) {
          for (var j = 0; j < carrate.length; j++) {
            html += "<br>" + carrate[j].Label + " - " + carrate[j].RateLabel;
          }
        }

        if (ratelist[i].Notes > "") html += "<br>" + ratelist[i].Notes;
      }
    }

    return html;
  };

  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    /*   console.log(f);
      var popup = {
          detail: true,
          content: showDetail2(f),
          marker: f
      } */
    var popup = showDetail2(f);
    app.tags.map.update({
      popup: popup
    });
  });
  $mn.on("layer/loaded/" + _feature, function (list) {
    //  app.tags.map.update(_legend);
    app.maplegend.init(_legend.legend).update();
  });
  /* 
      app.on("dataset/change", () => {
  
          var legend = { hide: true };
  
          $mn.layers.eachLayer(a => {
              let leg = { hide: true }
              app.trigger("map/legend/check/" + a, leg);
              legend.hide = legend.hide && leg.hide;
          });
  
          if (legend.hide && app.tags.map) {
              app.tags.map.update({ legend: null });
          }
  
          /* if (!app.isDatasetActive(_feature) && app.tags.map) {
               app.tags.map.update({ legend: null });
           }*/

  /*  }); */

  /*_map.trigger('layer/loaded/' + name, this.list[name])
  _map.trigger('layer/change')*/

  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      var url = "/assets/pointer/web-pointers-parking.svg";

      if (!fil["motorcycle"](feat.getProperty("json"))) {
        url = "/assets/pointer/web-pointers-motorbike-park-32.svg";
      }

      if (!fil["building"](feat.getProperty("free")) || feat.getProperty("label").indexOf("building") !== -1) {
        url = "/assets/pointer/web-pointers-parking-building-30.svg";
      }

      if (!fil["mobility"](feat.getProperty("json"))) {
        url = "/assets/pointer/web-pointers-mobility-park-29-29.svg";
      }

      if (!fil["120"](feat.getProperty("json"))) {
        url = "/assets/my/web-pointers-park-120-32.svg";
      }

      if (!fil["60"](feat.getProperty("json"))) {
        url = "/assets/my/web-pointers-park-60-32.svg";
      }

      if (!fil["30"](feat.getProperty("json"))) {
        url = "/assets/my/web-pointers-park-30-32.svg";
      }

      if (!fil["10"](feat.getProperty("json"))) {
        url = "/assets/my/web-pointers-park-10-32.svg";
      }

      if (!fil["5"](feat.getProperty("json"))) {
        url = "/assets/my/web-pointers-park-5-32.svg";
      }

      var strokeColor = {
        "P60": "rgb(5,104,57)",
        "P120": "rgb(100,33,101)",
        "Unrestricted": "rgb(255,147,38)"
      }[feat.getProperty("maxlength")] || "";
      var transparent = $mn.layers.isActiveFeature() && !feat.getProperty("active");

      if (transparent) {
        strokeColor = strokeColor.replace(")", ",0.5)");
      }

      url = "/assets/publica/sets/OnTheGo_Pin_Map.svg";
      var addstyle = {
        icon: {
          url: url,
          scaledSize: app.conf.mapIconSize()
        },
        visible: !feat.getProperty("hidden"),
        opacity: transparent ? 0.5 : 1,
        strokeColor: strokeColor,
        strokeWeight: 5
        /*  label: {
             color: 'red',
             fontSize: '12px', 
             fontWeight: 'bold',
             text: feat.getProperty("source")
         }, */

      };
      /* if (feat.getGeometry().getType() == "LineString") {
           console.log("LineString");
           addstyle.label = {
               color: strokeColor,
               fontSize: '12px',
               fontWeight: 'bold',
               text: feat.getProperty("maxlength")
           };
       }*/

      riot.util.misc.extend(_style, addstyle);
    }

    riot.util.misc.extend(style, _style);
  });
  var _live = {
    timer: 1000 * 60 * 3,
    data: [],
    alive: false,
    start: function start() {
      if (!this.alive) {
        clearInterval(this.alive);
        this.alive = setInterval(this.go, this.timer);
      }

      return this.alive;
    },
    stop: function stop() {
      if (this.alive) {
        clearInterval(this.alive);
      }
    },
    go: function go() {
      var _this = this;

      _lib.ajax.$get("/api/parking.php", function (data) {
        _this.data = JSON.parse(data);
        app.trigger("parking/live/update", _this.data);

        var mapdata = _lib.keep.need("map/parking");

        if (mapdata) {
          mapdata.features.filter(function (a) {
            return _this.data.some(function (b) {
              return b.oid == a.properties.Id;
            });
          }).forEach(function (a) {
            _this.data.filter(function (b) {
              return b.oid == a.properties.Id;
            }).forEach(function (b) {
              a.properties.free = b.free;
              a.properties.occupied = b.occupied;
              a.properties.status = b.status;
            });
          });
        }

        _lib.keep("map/parking", mapdata);

        $mn.layers.each(function (f) {
          if (_this.data.some(function (a) {
            return a.oid == f.getProperty("Id");
          })) {
            _this.data.filter(function (b) {
              return b.oid == f.getProperty("Id");
            }).forEach(function (b) {
              f.setProperty("free", b.free);
              f.setProperty("occupied", b.occupied);
              f.setProperty("status", b.status);
            });
          }
        });
      });
    }
  };
  app.on("force/go/parking", _live.go);
  app.on("parking/live/start", _live.start);
  app.on("parking/live/stop", _live.stop);
  app.on("dataset/change", function () {
    if (app.isDatasetActive(_feature)) {
      _live.start();
    } else {
      _live.stop();
    }
  });
})(app, riot);

(function (app, riot) {
  var _feature = "porthills-water";
  var _icon = "/assets/pointer/web-pointers-waterdrop.svg";
  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("Name"),
        desc: "",
        //a.getProperty("Status"),
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var html = f.getProperty("Name") + "<br>" + f.getProperty("description");
    var data = {
      location: {
        lat: e.latLng.lat(),
        lng: e.latLng.lng()
      },
      detail: {
        name: html
      }
    };
    var popup = {
      detail: true,
      content: html,
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          url: _icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
  /*   app.on("map/feature/style", function(feat, style) { // {feat, style}
       var _style = {};
      if (feat.getProperty("Toilet")) {
          riot.util.misc.extend(_style, {
              icon: {
                  url: "http://maps.google.com/mapfiles/kml/shapes/toilets.png",
                  scaledSize: new google.maps.Size(16, 16)
              }
          });
      }
      if (feat.getProperty("Water")) {
          riot.util.misc.extend(_style, {
              icon: {
                  url: "http://maps.google.com/mapfiles/kml/shapes/water.png",
                  scaledSize: new google.maps.Size(16, 16)
              }
          });
      }
        riot.util.misc.extend(style, _style);
  });
  */
})(app, riot);

(function (app, riot) {
  var _feature = "poweroutage";
  var _icon = "/assets/pointer/web-pointers-power.svg";
  var _legend = {
    legend: {
      list: [{
        icon: "/assets/pointer/web-pointers-power-gray.svg",
        label: "Past outages"
      }, {
        icon: "/assets/pointer/web-pointers-power-red.svg",
        label: "Current outages"
      }, {
        icon: "/assets/pointer/web-pointers-power.svg",
        label: "Planned outages"
      }]
    }
  };
  $mn.on("layer/loaded/" + _feature, function (list) {
    // app.tags.map.update(_legend);
    app.maplegend.init(_legend.legend).update();
  });
  /*  app.on("map/legend/check/" + _feature, function(obj) {
       obj.hide = false;
   });
  */

  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("streets"),
        desc: a.getProperty("timedown"),
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });

  function showDirectory(list) {
    var x = list.sort(function (a, b) {
      return a.getProperty("current") == 1 ? -1 : b.getProperty("current") == 1 ? 1 : 0;
    }).reduce(function (r, a) {
      r.push({
        title: a.getProperty("streets"),
        feat: a
      });
      return r;
    }, []); //console.log(x);

    app.alert.set({
      title: "Power outage directory",
      list: x,
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var details = [];

    if (f.getProperty("alternatedate") && f.getProperty("alternatedate") != "1970-01-01") {
      details.push({
        svgIcon: "Date",
        label: "Alternate date",
        value: f.getProperty("alternatedate")
      });
    }

    if (f.getProperty("comment") && f.getProperty("comment") != "") {
      details.push({
        label: "comment",
        value: f.getProperty("comment")
      });
    }

    details.push({
      label: "streets",
      value: f.getProperty("streets")
    });
    details.push({
      svgIcon: "Power",
      label: "Affected customers",
      value: f.getProperty("numberoff") || "0"
    });
    details.push({
      svgIcon: "Power",
      label: "Total customers",
      value: f.getProperty("maxnumberoff")
    });
    var popup = {
      detail: true,
      data: {
        title: f.getProperty("cause"),
        sub: f.getProperty("timedown"),
        details: details //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      var icon = _icon;
      var zindex = 1;
      /*  if (feat.getProperty("timeup") != "1970-01-01 12:00:00") {
                 icon = "/assets/pointer/web-pointers-power-gray.svg";
             } else if (moment(feat.getProperty("timedown")).isBefore() && (!moment(feat.getProperty("timeup")).isBefore() || feat.getProperty("timeup") == "1970-01-01 12:00:00")) {
                 icon = "/assets/pointer/web-pointers-power-red.svg";
             } */

      if (feat.getProperty("current") == 1) {} else if (feat.getProperty("current") == 0) {
        icon = "/assets/pointer/web-pointers-power-red.svg";
        zindex = 2;
      } else if (feat.getProperty("current") == -1) {
        icon = "/assets/pointer/web-pointers-power-gray.svg";
        zindex = 0;
      }

      riot.util.misc.extend(_style, {
        icon: {
          url: icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2",
        zIndex: zindex
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "pumpstations";
  var _icon = "/assets/pointer/water/fair.svg";
  var _icon_good = "/assets/pointer/water/good.svg";
  var _icon_fair = "/assets/pointer/water/fair.svg";
  var _icon_verypoor = "/assets/pointer/water/very-poor.svg";
  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      var icon, desc;

      if (a.getProperty("chlorination") == 'none') {
        icon = _icon_good;
        desc = "No chlorination";
      } else if (parseInt(a.getProperty("chlorination")) <= 0.5) {
        icon = _icon_fair;
        desc = "Chlorination level - " + a.getProperty("chlorination") + "";
      } else if (a.getProperty("chlorination").split(" ")[0] == "Out") {
        icon = _icon_verypoor;
        desc = "" + a.getProperty("chlorination") + "";
      } else {
        icon = _icon_verypoor;
        desc = "Chlorination level - " + a.getProperty("chlorination") + "";
      }

      return {
        icon: icon,
        name: a.getProperty("name"),
        desc: desc,
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Pump station directory",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("name"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var feat = f;

    if (f.getProperty("chlorination") == 'none') {
      icon = _icon_good;
      desc = "No chlorination";
    } else if (parseInt(f.getProperty("chlorination")) <= 0.5) {
      icon = _icon_fair;
      desc = "Chlorination level - " + f.getProperty("chlorination") + "";
    } else if (f.getProperty("chlorination").split(" ")[0] == "Out") {
      icon = _icon_verypoor;
      desc = "" + f.getProperty("chlorination") + "";
    } else {
      icon = _icon_verypoor;
      desc = "Chlorination level - " + f.getProperty("chlorination") + "";
    }

    var popup = {
      detail: true,
      data: {
        title: feat.getProperty("name"),
        sub: desc,
        details: [{
          image: '/assets/publica/sets/Find_Icon.svg',
          label: "more",
          html: "<a href='https://ccc.govt.nz/services/water-and-drainage/water-supply/water-chlorination' target=_blank>More information</a>"
        }] //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
    return;
    var html = f.getProperty("name");
    var icon, desc;

    if (f.getProperty("chlorination") == 0) {
      icon = _icon_good;
      desc = "No chlorination";
    } else if (f.getProperty("chlorination") <= 0.5) {
      icon = _icon_fair;
      desc = "Chlorination level - " + f.getProperty("chlorination") + "ppm";
    } else {
      icon = _icon_verypoor;
      desc = "Chlorination level - " + f.getProperty("chlorination") + "ppm";
    }

    html += "<br>" + desc;
    /* var data = {
        location: { lat: e.latLng.lat(), lng: e.latLng.lng() },
        detail: {
            name: f.getProperty("Name"),
            info: [
                { label: "Grade", text: f.getProperty("Grade") },
                { label: "Warning", text: f.getProperty("Warning") }
            ]
        }
    };
    */

    var popup = {
      detail: true,
      content: html,
      moreLink: "https://ccc.govt.nz/services/water-and-drainage/water-supply/water-chlorination",
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};
    var icon = _icon;

    if (feat.getProperty("feature") == _feature) {
      if (feat.getProperty("chlorination") == 'none') {
        icon = _icon_good; // desc = "No chlorination";
      } else if (parseInt(feat.getProperty("chlorination")) <= 0.5) {
        icon = _icon_fair; //  desc = "Chlorination level - " + feat.getProperty("chlorination") + "";
      } else if (feat.getProperty("chlorination").split(" ")[0] == "Out") {
        icon = _icon_verypoor; //  desc = "" + feat.getProperty("chlorination") + "";
      } else {
        icon = _icon_verypoor; //  desc = "Chlorination level - " + feat.getProperty("chlorination") + "";
      }

      riot.util.misc.extend(_style, {
        icon: {
          url: icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "bus-position";
  var _icon = "assets/icons/black/bus.png";
  var updateInterval;
  var lastUpdate = 0;
  var defaultInterval = 1000;
  var accurateInterval = false;
  var gTime = defaultInterval;
  var last;
  var bus_routes_colors = app.conf.bus_routes_colors; //{ "85": "241,91,76,255", "17": "236,0,140,255", "28": "247,147,40,255", "29": "0,83,159,255", "44": "0,116,173,255", "60": "218,111,171,255", "80": "113,125,189,255", "95": "179,136,8,255", "100": "136,128,126,255", "107": "70,162,153,255", "108": "162,133,179,255", "120": "250,166,26,255", "125": "95,153,55,255", "130": "159,57,37,255", "135": "13,177,75,255", "140": "0,146,158,255", "145": "149,100,56,255", "150": "152,83,161,255", "535": "210,191,165,255", "820": "70,186,124,255", "951": "0,157,178,255", "952": "128,206,202,255", "960": "241,91,78,255", "B": "62,188,237,255", "F": "0,88,153,255", "Gl": "255,218,0,255", "Gr": "0,182,181,255", "O": "243,112,33,255", "Oc": "121,188,67,255", "Or": "121,188,67,255", "Oa": "121,188,67,255", "P": "85,69,136,255", "TL": "191,110,173,255", "W": "0,182,181,255", "Y": "255,194,14,255" };

  var zoomPrecision = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2560, 1280, 640, 320, 160, 80, 60, 40, 20];
  var buses = [];
  var animInterval;
  app.on("map/feature/detail/" + _feature, function (map, f) {
    var html = f.getProperty("popup"); //  console.log(".......................");

    /*   f.toGeoJson((html) => {
          var popup = {
              detail: true,
              content: f.getProperty("popup"),
              marker: f
          };
           console.log(html);
           app.tags.map.update({ popup: popup });
      }); */

    var popup = {
      detail: true,
      content: html,
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
    /*   if (f.getProperty("poly")) {
          console.log("30: ", f.getProperty("position-30").lat(), f.getProperty("position-30").lng());
          console.log("60: ", f.getProperty("position-60").lat(), f.getProperty("position-60").lng());
          google.maps.event.trigger(f.getProperty("poly"), "click", { latLng: f.getGeometry().get() });
      }
      console.log("......................."); */
  });
  app.on("map/feature/style", function (feat, style) {
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        visible: false,
        icon: {
          url: "/assets/bus.svg",
          scaledSize: app.conf.mapIconSize()
        },
        zIndex: 5
      });
    }

    riot.util.misc.extend(style, _style);
  });

  function loadUpdateInterval() {
    last = moment(lastUpdate);

    if (last.add(30, "seconds").isBefore()) {
      _lib.ajax.$get("/app/router/bus_position.php?last=" + last, function (data) {
        if (data && updateInterval) {
          buses = JSON.parse(data);
          $mn.isMap().data.forEach(function (a) {
            if (a.getProperty("feature") == _feature && !buses.some(function (b) {
              return b.bus_id == a.getProperty("id");
            })) {
              $mn.isMap().data.remove(a);
            }
          });
          buses.forEach(function (bus) {
            var loc = JSON.parse(bus.loc);
            var f = $mn.isMap().data.getFeatureById(bus.bus_id);

            if (f) {
              var oldpos = f.getProperty("position-30");

              if (oldpos && oldpos.coordinates) {
                oldpos = new google.maps.LatLng(oldpos.coordinates[1], oldpos.coordinates[0]);
              }

              if (oldpos) {
                f.setProperty("position-60", oldpos);
              } else {
                f.setProperty("position-60", new google.maps.LatLng(loc.coordinates[1], loc.coordinates[0]));
              }

              f.setProperty("position-30", new google.maps.LatLng(loc.coordinates[1], loc.coordinates[0]));
              /*f.setGeometry(
                                              new google.maps.LatLng(loc.coordinates[1], loc.coordinates[0])
                                          );*/

              f.setProperty("accurate_on", bus.accurate_on);
              lastUpdate = bus.accurate_on;

              if (f.getProperty("PolyAnimator")) {
                f.getProperty("PolyAnimator").change();
              }
            } else {
              /*
              shape_id
              :
              161*/
              var n = new google.maps.Data.Feature({
                id: bus.bus_id,
                geometry: new google.maps.LatLng(loc.coordinates[1], loc.coordinates[0]),
                properties: {
                  accurate_on: bus.accurate_on,
                  feature: _feature,
                  destination: bus.trip_headsign,
                  shape_id: bus.shape_id,
                  trip_id: bus.trip_id,
                  id: bus.bus_id,
                  name: bus.route_id,
                  popup: bus.route_id,
                  "position-30": new google.maps.LatLng(loc.coordinates[1], loc.coordinates[0])
                }
              });
              $mn.layers.addOne($mn.isMap().data.add(n), _feature);
            }
          });
          last = moment(buses[0].accurate_on);
          start(-1 * moment().diff(last.clone().add(30, "seconds")));
        } else {
          accurateInterval = false;
          start(defaultInterval);
        }
      });
    } else {
      accurateInterval = false;
      start(defaultInterval);
    }
  }

  function start(time) {
    // console.log("start", time);
    if (time < 0) {
      time = defaultInterval;
      accurateInterval = false;
    }

    if (time != defaultInterval) {
      accurateInterval = true;
    }

    if (accurateInterval || time == defaultInterval && !accurateInterval) {
      updateInterval = clearTimeout(updateInterval);
      gTime = time;
      updateInterval = setTimeout(function () {
        loadUpdateInterval();
      }, time);
    }
  }

  app.on("map/feature/remove", function (map, f) {
    if (f.feature.getProperty("feature") == _feature) {
      if (f.feature.getProperty("poly")) {
        f.feature.getProperty("poly").setMap(null);
      }

      updateInterval = clearTimeout(updateInterval);
      animInterval = clearInterval(animInterval);
    }
  });

  function PolyAnimator(f, buslinefeature) {
    this.f = f;
    this.buslinefeature = buslinefeature;
    this.snap = null;
    this.color = "black";
    this.poly = null;

    this.change = function () {
      if (this.snap) {
        var snapget = this.snap.getAll(f.getProperty("position-30"));
        f.setProperty("snapget", snapget);
        /* if (f.getProperty("oldpoly")) {
            f.setProperty("animOffset", 0);
        } else {
            f.setProperty("animOffset", 50);
        } */

        f.setGeometry(snapget.latlng);
        f.setProperty("oldpoly", this.poly);
        followLineByDiff(f.getProperty("position-60"), f.getProperty("position-30"), this.buslinefeature.getGeometry(), snapget, this.snap, this.color, this.poly, f);
        var offset;
        /*if (f.getProperty("poly") && f.getProperty("poly").icons && f.getProperty("poly").icons.length > 0) {
            offset = parseFloat(f.getProperty("poly").icons[0].offset);
        } else {
            offset = 50;
        }*/

        offset = 50;
        f.setProperty("animOffset", offset);
      }
    };

    this.init = function () {
      var f = this.f;
      var buslinefeature = this.buslinefeature;
      f.setProperty("PolyAnimator", this);

      if (buslinefeature) {
        try {
          this.snap = new _maps.stSnap.cSnapToRoute();
          this.snap.init($mn.isMap(), buslinefeature.getGeometry());
          f.setProperty("buslinefeature", buslinefeature);
          f.setProperty("snap", this.snap);
          var pos30 = f.getProperty("position-30");

          if (pos30.lat) {
            var snapget = this.snap.getAll(pos30);
          } else {
            var snapget = this.snap.getAll(new google.maps.LatLng(pos30.coordinates[1], pos30.coordinates[0]));
          } // var snapget = this.snap.getAll(f.getGeometry().get());


          f.setProperty("snapget", snapget); //f.setGeometry(snapget.latlng);

          this.color = bus_routes_colors.get(f.getProperty("name"));
          this.color = "rgba(" + this.color + ")";

          if (!f.getProperty("position-60")) {
            f.setProperty("position-60", pos30);
          }

          var pos60 = f.getProperty("position-60");

          if (pos30.coordinates) {
            pos30 = new google.maps.LatLng(f.getProperty("position-30").coordinates[1], f.getProperty("position-30").coordinates[0]);
          }

          if (pos60.coordinates) {
            pos60 = new google.maps.LatLng(f.getProperty("position-60").coordinates[1], f.getProperty("position-60").coordinates[0]);
          }

          this.poly = followLineByDiff(pos60, pos30, buslinefeature.getGeometry(), snapget, this.snap, this.color, null, f);
          f.setProperty("poly", this.poly);

          if (f.getProperty("poly")) {
            clearInterval(f.getProperty("animBus"));
            f.setProperty("animOffset", 50);
            f.setProperty("animBus", setInterval(function () {
              try {
                var count = f.getProperty("animOffset");
                var line = f.getProperty("poly");

                if (f.getProperty("oldpoly")) {
                  count += 0.083 * 2;
                } else {
                  count += 0.083;
                }

                f.setProperty("animOffset", count);

                if (count >= 100) {
                  count = 100;
                } //  if (f.getProperty("id") == 373) console.log(count);


                var icons = line.get("icons");
                icons[0].offset = count + "%";
                line.set("icons", icons);
                /* var featpos;
                 var polyarray = line.getPath().getArray();
                 if (count >= 95) {
                     featpos = polyarray[polyarray.length - 1];
                 } else if (count <= 5) {
                     featpos = polyarray[0];
                 } else {
                     var len = google.maps.geometry.spherical.computeLength(polyarray);
                     len = count * len / 100;
                     var seglen = 0,
                         i = 1;
                     while (seglen < len && i < polyarray.length) {
                         seglen = google.maps.geometry.spherical.computeLength(polyarray.slice(0, i));
                         i++;
                     }
                     i--;
                     seglen = len - seglen;
                     var polyHeading = google.maps.geometry.spherical.computeHeading(
                         polyarray[i - 1],
                         polyarray[i]
                     );
                     featpos = google.maps.geometry.spherical.computeOffset(
                         polyarray[i - 1],
                         seglen,
                         polyHeading
                     );
                  }
                 f.setGeometry(featpos);*/
              } catch (e) {
                console.log(e); //debugger;
              }
            }, 50));
          }
        } catch (e) {
          console.log(f.getProperty("position-60"), f.getProperty("position-30"), buslinefeature.getGeometry(), snapget);
          console.log(e);
        }
      } else {
        console.log(this); //debugger;
      }
    };

    return this;
  }

  app.on("map/feature/add", function (map, f) {
    if (f.feature.getProperty("feature") == _feature) {
      lastUpdate = f.feature.getProperty("accurate_on");
      last = moment(lastUpdate);
      start(-1 * moment().diff(last.clone().add(30, "seconds")));
      var busline = f.feature.getProperty("name");
      var busdest = f.feature.getProperty("destination");
      var buspromise = new Promise(function (resolve, reject) {
        var buslinefeature = function (busline) {
          var x = false;
          var tempx = false;
          $mn.isMap().data.forEach(function (a) {
            if (a.getProperty("feature") == "bus-routes") {
              /*    if (a.getProperty("Name") == busline) {
                     tempx = a;
                  }
                 if (a.getProperty("Destination") == busdest) {
                     x = tempx = a;
                 } */
              if (a.getProperty("shape") == f.feature.getProperty("shape_id")) {
                x = a;
              }
            }
          });
          if (!x) x = tempx;
          return x;
        }(busline);

        if (buslinefeature) {
          // if (!buslinefeature.getGeometry().getArray) debugger;
          resolve(buslinefeature);
        } else {
          $mn.on("layer/loaded/bus-routes", function (list) {
            var x = false;
            var tempx = false;
            list.forEach(function (a) {
              /*  if (a.getProperty("Name") == busline) {
                   tempx = a;
                }
               if (a.getProperty("Destination") == busdest) {
                   x = tempx = a;
               } */
              if (a.getProperty("shape") == f.feature.getProperty("shape_id")) {
                x = a;
              }
            });
            if (!x) x = tempx; //  if (!x.getGeometry().getArray) debugger;

            resolve(x);
          });
        }
      });
      var projectionPromise = new Promise(function (resolve, reject) {
        var proj = $mn.isMap().getProjection();
        if (proj) resolve(proj);else {
          google.maps.event.addListenerOnce($mn.isMap(), "projection_changed", function () {
            proj = $mn.isMap().getProjection();
            resolve(proj);
          });
        }
      });
      projectionPromise.then(function (proj) {
        buspromise.then(function (buslinefeature) {
          var pA = new PolyAnimator(f.feature, buslinefeature);
          pA.init();
        });
      });
    }
  });

  function showPoints(animPolyArray) {
    for (var j = 0; j < animPolyArray.length; j++) {
      var marker = new google.maps.Marker({
        position: animPolyArray.getArray()[j],
        label: 'abcdefghijklmnopqrstuvwyz0123456789'.split("")[j],
        map: $mn.isMap(),
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 4,
          strokeColor: 'red'
        }
      });
    }
  }

  function followLineByDiff(past, current, line, snapget, snap, color, oldpoly, feature) {
    //wrong line snap
    // current = snapget.latlng;
    //console.log(current, snapget.latlng);
    var linecolor = color;
    var coar = linecolor.split(",");
    coar[coar.length - 1] = "0.3)";
    linecolor = coar.join(","); //console.log(linecolor);

    var lineweight = 50; //linecolor = "transparent";

    try {
      current = snapget.latlng;
      var currentLineIndex = snapget.i;
      var lineArray = line.getArray();
      var next = lineArray[currentLineIndex];
      var pastsnap = snap.getAll(past);
      past = pastsnap.latlng;
      var pastLineIndex = pastsnap.i; // if (pastLineIndex == currentLineIndex) debugger;
      // google.maps.geometry.spherical.computeLength([current,next]) < google.maps.geometry.spherical.computeLength())

      var reversed = false; //currentLineIndex < pastLineIndex || 
      //   if ((currentLineIndex == pastLineIndex && snapget.fTo > pastsnap.fTo)) {

      var distanceC = google.maps.geometry.spherical.computeLength([current, next]);
      var distanceP = google.maps.geometry.spherical.computeLength([past, next]);
      /*  if (distanceC > distanceP || (currentLineIndex == pastLineIndex && snapget.fTo < pastsnap.fTo)) {
            lineArray = lineArray.reverse();
            pastLineIndex = lineArray.length - pastLineIndex - 1;
            currentLineIndex = lineArray.length - currentLineIndex - 1;
            reversed = true;
        }*/

      var distPolyArray = [pastsnap.latlng];

      for (var i = pastLineIndex; i < currentLineIndex; i++) {
        distPolyArray.push(lineArray[i]);
      }

      distPolyArray.push(current);
      var pcDist = google.maps.geometry.spherical.computeLength(distPolyArray);
      pcDist = Math.min(pcDist, 500); //console.log(pcDist);
      //find best line index

      var animPolyArray = [current];
      var animPolyDist = 0;
      var tempDist = 0;
      var animNextLinePoint = currentLineIndex;

      while (tempDist < pcDist && animNextLinePoint < lineArray.length) {
        var tempArray = animPolyArray.concat([lineArray[animNextLinePoint]]);

        try {
          tempDist = google.maps.geometry.spherical.computeLength(tempArray);
        } catch (e) {
          console.log(tempArray);
        }

        if (tempDist < pcDist) {
          animPolyArray = tempArray;
          animPolyDist = tempDist;
          animNextLinePoint++;
        }

        if (animNextLinePoint == lineArray.length) {
          animNextLinePoint--;
          break;
        }
      }

      if (animNextLinePoint == 0) {} else {
        var polyHeading = google.maps.geometry.spherical.computeHeading(animPolyArray[animPolyArray.length - 1], lineArray[animNextLinePoint]);
        var newPoint = google.maps.geometry.spherical.computeOffset(animPolyArray[animPolyArray.length - 1], Math.max(pcDist - animPolyDist, 0.01), polyHeading);
        animPolyArray.push(newPoint);
      } //-30 to +30 start 50% poly
      //console.log(color);
      //if (color == "rgba(undefined)") debugger;


      var opt = {
        strokeColor: linecolor,
        strokeWeight: lineweight,
        icons: [{
          icon: {
            path: "M23.848,33.001c-4.551,0-8.184,3.639-8.184,8.177c0,4.512,3.633,8.171,8.184,8.171c4.505,0,8.151-3.659,8.151-8.171  C31.999,36.64,28.353,33.001,23.848,33.001z M23.828,45.26c-2.246,0-4.095-1.829-4.095-4.089c0-2.252,1.849-4.095,4.095-4.095  c2.266,0,4.088,1.843,4.088,4.095C27.917,43.431,26.094,45.26,23.828,45.26z M76.179,33.001c-4.525,0-8.184,3.639-8.184,8.177c0,4.512,3.658,8.171,8.184,8.171c4.505,0,8.17-3.659,8.17-8.171  C84.349,36.64,80.684,33.001,76.179,33.001z M76.179,45.26c-2.266,0-4.102-1.829-4.102-4.089c0-2.252,1.836-4.095,4.102-4.095  c2.246,0,4.082,1.843,4.082,4.095C80.261,43.431,78.425,45.26,76.179,45.26z M87.461,19.212L80.144,4.668C78.854,2.103,75.442,0,72.565,0H5.228C2.357,0,0,2.356,0,5.228v38.497h14.056  c-0.208-0.82-0.365-1.667-0.365-2.546c0-5.599,4.551-10.149,10.156-10.149c5.573,0,10.124,4.551,10.124,10.149  c0,0.879-0.156,1.726-0.364,2.546h32.792c-0.215-0.82-0.364-1.667-0.364-2.546c0-5.599,4.538-10.149,10.144-10.149  c5.586,0,10.137,4.551,10.137,10.149c0,0.879-0.15,1.726-0.365,2.546H100V32.389C100,29.511,95.69,20.182,87.461,19.212z   M21.328,19.212H3.998V3.874h17.331V19.212z M41.322,19.212H23.991V3.874h17.331V19.212z M61.309,19.212H43.984V3.874h17.324V19.212z M66.263,19.212V3.874h5.176c1.836,0,4.011,1.341,4.831,2.975l6.218,12.363H66.263z",
            scale: 0.3,
            strokeColor: color,
            strokeWeight: 2,
            rotation: 270,
            anchor: new google.maps.Point(50, 50)
          },
          offset: "50%"
        }]
      };

      if (oldpoly) {
        poly = oldpoly; // var oldArray = oldpoly.getPath().getArray();

        /*  oldArray.sort((a, b) => {
              var as = snap.getAll(a);
              var bs = snap.getAll(b);
              var r = 0;
              if (a.i > b.i) r = 1;
              else if (a.i < b.i) r = -1;
              else if (a.fTo > b.fTo) r = 1;
              else if (a.fTo < b.fTo) r = -1;
              if (reversed) r = r * -1;
              return r;
          });*/

        /*   var lastOld = oldArray.pop();
           var last2ndOld = oldArray.pop();*/

        var st = 0;
        /* if (lastOld && last2ndOld) {
             if (google.maps.geometry.spherical.computeLength([lastOld, animPolyArray[0]]) <= google.maps.geometry.spherical.computeLength([last2ndOld, animPolyArray[0]])) {
                 var lastsnap = snap.getAll(lastOld);
                 var lasti = lastsnap.i;
                 if (reversed) {
                     lasti = lineArray.length - lasti - 1;
                 }
                   var lastPolyArray = [lastOld];
                   for (var i = lasti; i < currentLineIndex; i++) {
                     lastPolyArray.push(lineArray[i]);
                 }
                   lastPolyArray.push(current);
                  animPolyArray = lastPolyArray; // lastPolyArray.concat(animPolyArray);
                 if (google.maps.geometry.spherical.computeLength(lastPolyArray) <= 10) {
                     animPolyArray = oldpoly.getPath();
                     st = 99;
                 }
                 //animPolyArray.unshift(lastOld);
             } else {
                 animPolyArray = oldpoly.getPath();
                 st = 99;
             }
         }*/

        st = 50;
        poly.setPath(animPolyArray);
        opt.icons = [{
          icon: {
            path: "M23.848,33.001c-4.551,0-8.184,3.639-8.184,8.177c0,4.512,3.633,8.171,8.184,8.171c4.505,0,8.151-3.659,8.151-8.171  C31.999,36.64,28.353,33.001,23.848,33.001z M23.828,45.26c-2.246,0-4.095-1.829-4.095-4.089c0-2.252,1.849-4.095,4.095-4.095  c2.266,0,4.088,1.843,4.088,4.095C27.917,43.431,26.094,45.26,23.828,45.26z M76.179,33.001c-4.525,0-8.184,3.639-8.184,8.177c0,4.512,3.658,8.171,8.184,8.171c4.505,0,8.17-3.659,8.17-8.171  C84.349,36.64,80.684,33.001,76.179,33.001z M76.179,45.26c-2.266,0-4.102-1.829-4.102-4.089c0-2.252,1.836-4.095,4.102-4.095  c2.246,0,4.082,1.843,4.082,4.095C80.261,43.431,78.425,45.26,76.179,45.26z M87.461,19.212L80.144,4.668C78.854,2.103,75.442,0,72.565,0H5.228C2.357,0,0,2.356,0,5.228v38.497h14.056  c-0.208-0.82-0.365-1.667-0.365-2.546c0-5.599,4.551-10.149,10.156-10.149c5.573,0,10.124,4.551,10.124,10.149  c0,0.879-0.156,1.726-0.364,2.546h32.792c-0.215-0.82-0.364-1.667-0.364-2.546c0-5.599,4.538-10.149,10.144-10.149  c5.586,0,10.137,4.551,10.137,10.149c0,0.879-0.15,1.726-0.365,2.546H100V32.389C100,29.511,95.69,20.182,87.461,19.212z   M21.328,19.212H3.998V3.874h17.331V19.212z M41.322,19.212H23.991V3.874h17.331V19.212z M61.309,19.212H43.984V3.874h17.324V19.212z M66.263,19.212V3.874h5.176c1.836,0,4.011,1.341,4.831,2.975l6.218,12.363H66.263z",
            scale: 0.3,
            strokeColor: color,
            strokeWeight: 2,
            rotation: 270,
            anchor: new google.maps.Point(50, 50)
          },
          offset: st + "%"
        }];
        poly.setOptions(opt);
      } else {
        var poly = new google.maps.Polyline({
          path: animPolyArray,
          map: $mn.isMap(),
          strokeColor: linecolor,
          strokeWeight: lineweight,
          icons: [{
            icon: {
              path: "M23.848,33.001c-4.551,0-8.184,3.639-8.184,8.177c0,4.512,3.633,8.171,8.184,8.171c4.505,0,8.151-3.659,8.151-8.171  C31.999,36.64,28.353,33.001,23.848,33.001z M23.828,45.26c-2.246,0-4.095-1.829-4.095-4.089c0-2.252,1.849-4.095,4.095-4.095  c2.266,0,4.088,1.843,4.088,4.095C27.917,43.431,26.094,45.26,23.828,45.26z M76.179,33.001c-4.525,0-8.184,3.639-8.184,8.177c0,4.512,3.658,8.171,8.184,8.171c4.505,0,8.17-3.659,8.17-8.171  C84.349,36.64,80.684,33.001,76.179,33.001z M76.179,45.26c-2.266,0-4.102-1.829-4.102-4.089c0-2.252,1.836-4.095,4.102-4.095  c2.246,0,4.082,1.843,4.082,4.095C80.261,43.431,78.425,45.26,76.179,45.26z M87.461,19.212L80.144,4.668C78.854,2.103,75.442,0,72.565,0H5.228C2.357,0,0,2.356,0,5.228v38.497h14.056  c-0.208-0.82-0.365-1.667-0.365-2.546c0-5.599,4.551-10.149,10.156-10.149c5.573,0,10.124,4.551,10.124,10.149  c0,0.879-0.156,1.726-0.364,2.546h32.792c-0.215-0.82-0.364-1.667-0.364-2.546c0-5.599,4.538-10.149,10.144-10.149  c5.586,0,10.137,4.551,10.137,10.149c0,0.879-0.15,1.726-0.365,2.546H100V32.389C100,29.511,95.69,20.182,87.461,19.212z   M21.328,19.212H3.998V3.874h17.331V19.212z M41.322,19.212H23.991V3.874h17.331V19.212z M61.309,19.212H43.984V3.874h17.324V19.212z M66.263,19.212V3.874h5.176c1.836,0,4.011,1.341,4.831,2.975l6.218,12.363H66.263z",
              scale: 0.3,
              strokeColor: color,
              strokeWeight: 2,
              rotation: 270,
              anchor: new google.maps.Point(50, 50)
            },
            offset: "50%"
          }]
        });
        google.maps.event.addListener(poly, "click", function (h) {
          var map = $mn.isMap();
          var par = this.getPath().getArray();
          var len = google.maps.geometry.spherical.computeLength(par);
          var relpos = parseFloat(this.icons[0].offset);
          var curpos = relpos * len / 100;
          var seglen = 0;
          var segarray = [];

          for (var i = 0; i < par.length; i++) {
            segarray = par.slice(0, i + 1);
            seglen = google.maps.geometry.spherical.computeLength(segarray);

            if (seglen >= curpos) {
              var oneless = segarray.slice(0, segarray.length - 1);
              var onelesslen = google.maps.geometry.spherical.computeLength(oneless);
              var lenleft = curpos - onelesslen;
              var f = segarray.pop();
              var l = oneless.pop();
              var f2l = google.maps.geometry.spherical.computeLength([f, l]);
              var iconpoint = google.maps.geometry.spherical.interpolate(f, l, lenleft / f2l); //console.log("bus clicked", google.maps.geometry.spherical.computeLength([iconpoint, h.latLng]));

              if (google.maps.geometry.spherical.computeLength([iconpoint, h.latLng]) < zoomPrecision[map.getZoom()]) {
                console.log("bus clicked", feature.getProperty("name"), feature);
                var html = "\n                                    Realtime GPS bus position<br>\n                                    Bus route: ".concat(feature.getProperty("name"), "<br>\n                                    Destination: ").concat(feature.getProperty("destination"), "<br>\n\n                                ");
                var popup = {
                  tag: 'popup-bus',
                  content: {
                    name: feature.getProperty("name"),
                    destination: feature.getProperty("destination"),
                    id: feature.getProperty("id"),
                    shape_id: feature.getProperty("shape_id"),
                    trip_id: feature.getProperty("trip_id"),
                    html: html
                  }
                  /*    marker: f */

                };
                app.tags.map.update({
                  popup: popup
                });
              }

              break;
            }
            /* if (seglen > curpos - 50 && seglen < curpos + 50) {
                 console.log("Len match", seglen, curpos);
             }*/

          } //h.latLng
          // currentLineIndex == pastLineIndex && snapget.fTo > pastsnap.fTo
          //console.log("Heading: ", polyHeading);

          /*   showPoints(this.getPath());
             console.log("----------------------------------------------------------");
             console.log("current: ", JSON.stringify(current));
            console.log("past: ", JSON.stringify(past));
            console.log("next: ", JSON.stringify(next));
               console.log("currentLineIndex: ", currentLineIndex);
             console.log("pastLineIndex: ", pastLineIndex);
            console.log("snapget.fTo: ", snapget.fTo);
            console.log("pastsnap.fTo: ", pastsnap.fTo);
            console.log("reversed: ", reversed);
            console.log("distanceC: ", distanceC);
            console.log("distanceP: ", distanceP);
            console.log("event", h); */

          /*   var marker = new google.maps.Marker({
                position: lineArray[animNextLinePoint - 1],
                label: '0',
                map: $mn.isMap()
            });
            var marker = new google.maps.Marker({
                position: lineArray[animNextLinePoint],
                label: '1',
                map: $mn.isMap()
            });
            var marker = new google.maps.Marker({
                label: 'N',
                position: newPoint,
                map: $mn.isMap()
            });
            var marker = new google.maps.Marker({
                label: 'P',
                position: past,
                map: $mn.isMap()
            });
            var marker = new google.maps.Marker({
                label: 'C',
                position: current,
                map: $mn.isMap()
            }); */

        });
      }
    } catch (e) {
      console.log(e); // debugger;
    }

    return poly;
  }

  function animateBus() {
    /*   var _last = last.clone().add(30, "seconds");
        $mn.isMap().data.forEach(f => {
           if (f.getProperty("feature") == _feature) {
               var d;
               var l = f.getGeometry().get();
                if ((d = f.getProperty("destPoint"))) {
                   if (google.maps.geometry.spherical.computeDistanceBetween(d, l) > 0) {
                       var s = f.getProperty("startPoint");
                        /* var dif = 30000 - Math.max(0, Math.min(_last.diff(), 30000));                        
                                                var t = dif / (30000);                     
                                                var n = google.maps.geometry.spherical.interpolate(s, d, t);*/
    // f.setGeometry(n);

    /*     }
            }
        }
    });*/
  }
})(app, riot);

(function (app, riot) {
  var _feature = "rubbishcollection";
  var _page = "rubbishcollection";
  var _icon = "assets/icons/black/mountain-bike.png";
  app.modules.add(_feature, {
    location: {
      lat: 0,
      lng: 0
    },
    locationName: "",
    getPopupText: function getPopupText() {
      return "Do you want to get notified when your rubbish bins are due? Notifications will be for: " + this.locationName;
    },
    getSignalData: function getSignalData() {
      return {
        location: {
          "type": "Point",
          "coordinates": [this.location.lng, this.location.lat]
        }
      };
    }
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      var color = "rgba(0,0,255,0.1)";
      /*if (feat.getProperty("type") == "refuse") {
          color = "red";
      } else if (feat.getProperty("type") == "recycling") {
          color = "yellow";
      } else if (feat.getProperty("type") == "organic") {
          color = "green";
      }*/

      if (feat.getProperty("day") == 1) {
        color = "white";
      } else if (feat.getProperty("day") == 2) {
        color = "green";
      } else if (feat.getProperty("day") == 3) {
        color = "gold";
      } else if (feat.getProperty("day") == 4) {
        color = "orange";
      } else if (feat.getProperty("day") == 5) {
        color = "darkblue";
      } else if (feat.getProperty("day") == 6) {
        color = "maroon";
      } else if (feat.getProperty("day") == 7) {
        color = "white";
      }

      riot.util.misc.extend(_style, {
        fillColor: color,
        strokeWeight: 4,
        strokeOpacity: 0.8,
        strokeColor: color,
        zIndex: feat.getProperty("day")
      });
    }

    riot.util.misc.extend(style, _style);
  }); //app.on("map/feature/detail/" + _feature, function (map, f, e) {

  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var collectionTimes;
    var colors = {
      "refuse": "red",
      "organic": "green",
      "recycling": "yellow"
    };
    var days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    var url = "/app/router/rubish.php?";
    url += "lat=" + e.latLng.lat();
    url += "&lng=" + e.latLng.lng();

    _lib.ajax.$get(url, function (data) {
      collectionTimes = JSON.parse(data);
      collectionTimes.forEach(function (a) {
        if (a.frequency == "Not Collected") {
          a.text = "Not Collected";
          a.days = "";
        } else {
          a.toweek = a.week == Number(moment().week() % 2 + 1) ? 1 : 2;

          if (a.frequency == "Weekly") {
            a.toweek = 1;
          } else {
            if (a.type == "refuse") {
              a.toweek = a.toweek % 2 + 1;
            }
          }

          if (a.toweek == 1) {
            if (a.day < moment().day()) {
              a.days = (a.frequency == "Weekly" ? 7 : 14) + a.day - moment().day();
            } else {
              a.days = a.day - moment().day();
            }
          } else {
            a.days = 7 + a.day - moment().day();
          }

          var tt = a.days < 7 ? "this" : "next";

          if (a.days + moment().day() < 7) {
            tt = "this";
            a.text = days[a.day] + " " + tt + " week <br>";
          } else if (a.days + moment().day() < 14) {
            tt = "next";
            a.text = days[a.day] + " " + tt + " week <br>";
          } else {
            tt = "";
            a.text = days[a.day] + " in 2 weeks <br>";
          }

          if (a.days > 0) {
            a.text += " (in " + a.days + " days)";
          } else {
            a.text += " (today)";
          }
          /*a.days = a.days;
          var tt = a.days < 7 ? "this" : "next";
          a.text = days[a.day] + " " + tt + " week <br>";
          if (a.days > 0) {
              a.text += " (in " + a.days + " days)";
          } else {
              a.text += " (today)";
          }*/

        }
      });
      collectionTimes.sort(function (a, b) {
        return a.days - b.days;
      });
      var tr = "";
      collectionTimes.forEach(function (a) {
        tr += "<tr  class=\"bin bin-".concat(colors[a.type], "\">\n                <td>\n                    <img height=20 src=\"/assets/my/bin-").concat(colors[a.type], ".png\"></td>\n                <td>\n                    ").concat(a.text, "\n                </td>\n                <td class=\"small-width-hide\"><span>").concat(a.description, "</span></td>\n                <td><span>").concat(a.frequency, "</span></td>\n\n            </tr>");
      });
      var html = "<table width=100%>\n                                ".concat(tr, "\n                           </table>");
      var popup = {
        detail: true,
        content: html
      };
      app.tags.map.update({
        popup: popup
      });
    });
  });
})(app, riot);

(function (app, riot) {
  var _feature = "sensibel";
  var hexgrid = [];

  function createHexGrid() {
    var radius = 200;

    var points = $mn.layers.list[_feature].slice(0); // === Hexagonal grid ===


    var point = new google.maps.LatLng(-43.368963, 172.356860);
    var map = $mn.isMap();
    var borderColor = "transparent";

    var hex1 = _maps.PolygonRegularPoly(point, radius, 6, 90, borderColor, 1, 1, "#00ff00", 0.5);

    hex1.setMap(map);
    var d = 2 * radius * Math.cos(Math.PI / 6);
    hexgrid.push(hex1);
    var rownum = 100;
    var colnum = 100;
    /* rows */

    var p = point;

    for (var row = 0; row <= rownum; row++) {
      var hex;

      if (row > 0) {
        p = _maps.EOffsetBearing(p, d, row % 2 ? 150 : 210);
        hex = _maps.PolygonRegularPoly(p, radius, 6, 90, borderColor, 1, 1, "#00ffff", 0.5);
        hex.setMap(map);
        hexgrid.push(hex);
      } else {
        hex = hex1;
      }

      var pp = p;

      for (var col = 0; col <= colnum; col++) {
        pp = _maps.EOffsetBearing(pp, d, 90);
        hex = _maps.PolygonRegularPoly(pp, radius, 6, 90, borderColor, 1, 1, "#00ffff", 0.5); //  hex.setMap(map);
        //console.log(_maps.PolygonRegularDataPoly(pp, radius, 6, 90, borderColor, 1, 1, "#00ffff", 0.5));

        map.data.add({
          geometry: _maps.PolygonRegularDataPoly(pp, radius, 6, 90, borderColor, 1, 1, "#00ffff", 0.5)
        });
        /*  for (var i = points.length - 1; i >= 0; i--) {
              if (google.maps.geometry.poly.containsLocation(points[i].getGeometry().get(), hex)) {
                  if (!hex.contains) {
                      hex.contains = 0;
                  }
                  hex.contains++;
                  points.splice(i, 1);
               }
          }*/

        hexgrid.push(hex);
      }
    } //console.log($mn.layers.list[_feature]);

  }

  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var html = "";
    var bad = f.getProperty("bad");
    var good = f.getProperty("good");
    var total = parseInt(bad) + parseInt(good);
    var frac = good > bad ? 1 - bad / good : good / bad;
    html = "Out of ".concat(total, " responses ").concat(good, " had a good experience and ").concat(bad, " had a bad experience in this location "); //console.log(html);

    var popup = {
      detail: true,
      content: html
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/remove", function (map, f) {
    if (f.feature.getProperty("feature") == _feature) {}
  });
  /*  app.on('map/legend/check/' + _feature, function(obj) {
       obj.hide = false
   });
  */

  $mn.on("layer/loaded/" + _feature, function (list) {
    var _legend = {
      legend: {
        list: []
      }
    };

    _legend.legend.list.push({
      line: "linear-gradient(to right, red, yellow)",
      label: "bad to neutral experience"
    });

    _legend.legend.list.push({
      line: "linear-gradient(to right, yellow, lime)",
      label: "neutral to great experience"
    });

    _legend.legend.list.push({
      label: "Share your experience",
      icon: "https://map.sensibel.org/img/logo2.svg",
      link: "https://map.sensibel.org/#!/signup"
    }); // app.tags.map.update(_legend);


    app.maplegend.init(_legend.legend).update(); //createHexGrid();

    /* $mn.layers.list[_feature].forEach(a => {
         for (var i = 0; i < hexgrid.length; i++) {
             if (google.maps.geometry.poly.containsLocation(a.getGeometry().get(), hexgrid[i])) {
                 if (!hexgrid[i].contains) {
                     hexgrid[i].contains = 0;
                 }
                 hexgrid[i].contains++;
                 break;
             }
         }
     });*/
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      var color;
      var bad = parseInt(feat.getProperty("bad"));
      var good = parseInt(feat.getProperty("good"));

      if (bad > good) {
        color = "red";
      } else if (good > bad) {
        color = "green";
      } else {
        color = "yellow;";
      }

      var total = bad + good;
      var frac = good > bad ? 1 - bad / good : good / bad; //console.log(good, bad, frac);

      color = _lib.colorGradient(frac, {
        red: 255,
        green: 0,
        blue: 0
      }, {
        red: 255,
        green: 255,
        blue: 0
      }, {
        red: 0,
        green: 255,
        blue: 0
      });
      var opacity = Math.min(total / 10, 1) / 0.8 + 0.2;
      color = _lib.colorGradient(opacity, {
        red: 255,
        green: 255,
        blue: 255
      }, color);
      opacity = 0.8;
      color = 'rgb(' + color.red + ',' + color.green + ',' + color.blue + ')';
      riot.util.misc.extend(_style, {
        strokeWeight: 1,
        strokeColor: "rgba(255, 255, 255, 0.5)",
        fillColor: color,
        fillOpacity: opacity
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "streetart";
  var _icon = "/assets/publica/sets/Find_Pin_Map.svg"; //"assets/pointer/web-pointers-streetart.svg";

  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature && a.getProperty("data");
    }).map(function (a) {
      return {
        icon: _icon,
        img: "https://watchthisspace.org.nz" + a.getProperty("data").thumbnail,
        desc: a.getProperty("data").title == "" ? a.getProperty("popup") : a.getProperty("data").title,
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });
  app.on("list/filter/apply/" + _feature, function (d) {
    var showlist = d.filters.reduce(function (r, a) {
      return r.concat(a.list.filter(function (a) {
        return a.checked;
      }));
    }, []);
    d.list.forEach(function (a) {
      a.hide = !showlist.every(function (b) {
        return b.filter(a);
      });
    });
    d.finished();
  });
  app.on("list/filter-data/" + _feature, function (filterData) {
    /* filterData[0] = {
         label: "Category",
         name: "Category",
         list: [{
                 name: "Graffiti",
                 filter: a =>
                     "Graffiti" == (b => b.category ? b.category.name : false)(JSON.parse(a.data.data))
             },
             {
                 name: "Sculpture",
                 filter: a =>
                     "Sculpture" == (b => b.category ? b.category.name : false)(JSON.parse(a.data.data))
             },
             {
                 name: "Mural",
                 filter: a =>
                     "Mural" == (b => b.category ? b.category.name : false)(JSON.parse(a.data.data))
             },
             {
                 name: "Indoor",
                 filter: a =>
                     "Indoor" == (b => b.category ? b.category.name : false)(JSON.parse(a.data.data))
             },
             {
                 name: "Public art",
                 filter: a =>
                     "Public art" == (b => b.category ? b.category.name : false)(JSON.parse(a.data.data))
             },
             {
                 name: "Transitional City Project",
                 filter: a =>
                     "Transitional City Project" == (b => b.category ? b.category.name : false)(JSON.parse(a.data.data))
             },
             {
                 name: "Utility box",
                 filter: a =>
                     "Utility box" == (b => b.category ? b.category.name : false)(JSON.parse(a.data.data))
             },
             {
                 name: "Stencil",
                 filter: a =>
                     "Stencil" == (b => b.category ? b.category.name : false)(JSON.parse(a.data.data))
             },
           ]
     };*/
    filterData[0] = {
      label: "Location",
      name: "Location",
      list: [{
        name: "CBD",
        filter: function filter(a) {
          return 14 == a.values[3];
        }
      }, {
        name: "New Brighton",
        filter: function filter(a) {
          return 16 == a.values[3];
        }
      }, {
        name: "Sydenham",
        filter: function filter(a) {
          return 15 == a.values[3];
        }
      }]
    };
  });
  app.on("list/click/" + _feature, function (item) {
    //console.log(item);
    route("play/streetart/" + item.data.oid);
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Streetart directory",
      list: list.reduce(function (r, a) {
        var dd = a.getProperty("data");
        if (!dd) return r;
        var name = "";

        if (dd.title > "") {
          name = dd.title;
        } else if (dd.artists.length > 0) {
          name = "".concat(dd.artists[0].name);
          if (dd.street > "") name += "@ ".concat(dd.street);
        }

        r.push({
          title: name,
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var dd = f.getProperty("data");
    if (!dd) return;
    var name = "";

    if (dd.title > "") {
      name = dd.title;
    } else if (dd.artists.length > 0) {
      name = "".concat(dd.artists[0].name);
      if (dd.street > "") name += "@ ".concat(dd.street);
    }

    var feat = f;
    var popup = {
      detail: true,
      data: {
        title: name,
        image: "https://watchthisspace.org.nz/" + dd.image,
        sub: "" //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
    return;
    var dd = f.getProperty("data");
    if (!dd) return;
    var name = "";

    if (dd.title > "") {
      name = dd.title;
    } else if (dd.artists.length > 0) {
      name = "".concat(dd.artists[0].name);
      if (dd.street > "") name += "@ ".concat(dd.street);
    }
    /* var detail = {
        name: name,
         link: "https://christchurchstreetart.org.nz/artwork/" + f.getProperty("oid"),
        info: [
            { label: "Description", text: dd.description || dd.submitter_description },
            // { label: "Category", text: dd.category.name },
            { label: "Commissioned", text: dd.commission_date }
         ]
    }
    if (dd.artists.length > 0) {
        for (let i = 0; i < dd.artists.length; i++) {
            detail.info.push({ label: "Artist", text: dd.artists[i].name });
        }
    }
    if (dd.decomission_date > "") {
        detail.info.push({
            label: "Decomissioned",
            text: dd.decomission_date
        });
    }
    // console.log(dd);
    detail.image = "https://watchthisspace.org.nz/" + dd.image; //+ ".250x250_q85.jpg"
     var data = {
        location: { lat: e.latLng.lat(), lng: e.latLng.lng() },
        detail: detail
    };
    */


    var html = "<img height=200 src='https://watchthisspace.org.nz" + dd.thumbnail + "'>";
    var popup = {
      detail: true,
      detailLink: "play/streetart/" + dd.id,
      content: html,
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          url: _icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "toilets";
  var _icon = "/assets/publica/sets/Find_Pin_Map.svg"; // "/assets/pointer/web-pointers-toilets.svg";

  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("Name"),
        desc: "",
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Public toilets directory",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("Name"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var feat = f;
    var popup = {
      detail: true,
      data: {
        title: feat.getProperty("Name"),
        sub: ""
      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
    return;
    var html = f.getProperty("Name");
    var data = {
      location: {
        lat: e.latLng.lat(),
        lng: e.latLng.lng()
      },
      detail: {
        name: html
      }
    };
    var popup = {
      detail: true,
      content: html,
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          url: _icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "tfc-road-works";
  var _feature2 = "tfc-closed-roads";
  var _feature_focus_point = "tfc_focus_point"; // var _icon = "assets/pointer/web-pointers-roadcone.svg";

  var _icon = "/assets/publica/sets/OnTheGo_Pin_Map.svg";
  var _lastActive = null;
  var _colors = {
    fill: "rgba(0,150,0,0.9)",
    stroke: "rgba(0,0,0,0.3)",
    fillActive: 'rgba(150,0,0,0.5)',
    strokeActive: "rgba(150,0,0,0.8)"
  };
  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return [_feature, _feature2].indexOf(a.getProperty("feature")) > -1;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("title"),
        desc: a.getProperty("Starts") + " - " + a.getProperty("Ends"),
        location: a.getGeometry(),
        feat: a
      };
    }).sort(function (a, b) {
      var da = google.maps.geometry.spherical.computeDistanceBetween($mn.isMap().getCenter(), a.feat.getProperty("focus_marker").getGeometry().get());
      var db = google.maps.geometry.spherical.computeDistanceBetween($mn.isMap().getCenter(), b.feat.getProperty("focus_marker").getGeometry().get());
      return da - db;
    });
    data.cb(list);
  });
  app.on("search/click/" + "roadworks", function (item) {
    route("map", {
      detail: _feature,
      map: {
        center: item.obj.data.location,
        zoom: 15,
        clear: true
      },
      clear: true
    });
  });
  app.on("search/query", function (q, cb, register) {
    register(_feature, true);

    _lib.ajax.$get("/app/router/search.php?traffic&q=" + q, function (data) {
      var results = [];
      var json = JSON.parse(data);
      if (json && Array.isArray(json.list)) json.list.forEach(function (item) {
        results.push({
          options: json.options,
          label: item.label,
          type: "Roadworks",
          dataset: "roadworks",
          obj: item,
          image: _icon
        });
      });
      cb(results, _feature);
    });
  });

  var _showDetail = function _showDetail(map, f, e) {
    /*   var popup = {
          tag: 'popup-traffic',
          content: {
              title: f.getProperty("title"),
              Starts: f.getProperty("Starts"),
              Ends: f.getProperty("Ends"),
               Notes: f.getProperty("Notes"),
              joblevels: f.getProperty("joblevels"),
              Description: f.getProperty("Description")
          }
      } */
    var popup = {
      detail: true,
      data: {
        //item.properties.Name||item.properties.Description
        title: f.getProperty("title"),
        sub: f.getProperty("Name") || f.getProperty("Description"),
        details: [{
          svgIcon: "Date",
          label: "Starts",
          value: f.getProperty("Starts")
        }, {
          svgIcon: "Date",
          label: "Ends",
          value: f.getProperty("Ends")
        }, {
          svgIcon: "Rate",
          label: "Notes",
          value: f.getProperty("Notes")
        }]
      }
    };
    map.data.revertStyle();
    map.data.overrideStyle(f.getProperty("parent"), {
      fillColor: _colors.fillActive,
      strokeColor: _colors.strokeActive
    });

    if (_lastActive) {
      _lastActive.setProperty("active", false);
    }

    _lastActive = f;
    f.setProperty("active", true);
    app.tags.map.update({
      popup: popup
    });
  };

  app.on("map/feature/detail/" + _feature, _showDetail);
  app.on("map/feature/detail/" + _feature2, _showDetail);
  app.on("map/feature/detail/" + _feature_focus_point, function (map, f, e) {
    _showDetail(map, f.getProperty("parent"), e);
  });
  app.on("map/feature/add", function (map, f) {
    if ([_feature, _feature2].indexOf(f.feature.getProperty("feature")) > -1) {
      var marker = new google.maps.Data.Feature({
        geometry: {
          lat: f.feature.getProperty("focus_point").coordinates[1],
          lng: f.feature.getProperty("focus_point").coordinates[0]
        },
        id: f.feature.getProperty("oid"),
        properties: {
          feature: _feature_focus_point,
          parent: f.feature
        }
      });
      map.data.add(marker);
      f.feature.setProperty("focus_marker", marker);
    }
  });
  app.on("map/feature/remove", function (map, f) {
    if ([_feature, _feature2].indexOf(f.feature.getProperty("feature")) > -1) {
      map.data.remove(f.feature.getProperty("focus_marker"));
    }
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if ([_feature, _feature2].indexOf(feat.getProperty("feature")) > -1) {
      riot.util.misc.extend(_style, {
        strokeColor: feat.getProperty("active") ? _colors.strokeActive : _colors.stroke,
        fillColor: feat.getProperty("active") ? _colors.fillActive : _colors.fill
      });
    }

    if (feat.getProperty("feature") == _feature_focus_point) {
      riot.util.misc.extend(_style, {
        icon: {
          url: _icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

;

(function (app, riot) {
  var _feature = 'trees';
  var _visible = false;
  var _legend = {
    legend: {
      list: [],
      filter: {
        show: false,
        options: []
      },
      name: _feature
    }
  };
  var _filterActive = false;
  var _filterList = [];

  var _boundsTT;

  app.on('map/feature/detail/' + _feature, function (map, f, e) {
    var feat = f;
    var popup = {
      detail: true,
      data: {
        title: feat.getProperty('Name'),
        sub: feat.getProperty('Botanical') // content: html

      } // marker: feat

    };
    console.log(feat);
    app.tags.map.update({
      popup: popup
    });
  });
  /* app.on('map/legend/check/' + _feature, function(obj) {
      obj.hide = false
  }) */

  function legendRefresh() {
    clearTimeout(_boundsTT);

    if ($mn.layers.has(_feature)) {
      if (_legend.legend.list.length > 0 && app.tags.mapLegend) {
        _boundsTT = setTimeout(function () {
          var legfilter = {
            legend: {
              list: [],
              filter: _legend.legend.filter,
              name: _feature
            }
          };

          if (!_filterActive) {
            legfilter.legend.list = _legend.legend.list.filter(function (a) {
              return $mn.layers.getVisible().some(function (b) {
                return a.label == b.getProperty('group');
              });
            }); //app.tags.mapLegend.update({ opts: { dataLegend: legfilter.legend, clearLegend:true } })

            app.maplegend.init(legfilter.legend).update();
          } else {
            legfilter.legend.list = _legend.legend.list.filter(function (a) {
              return _filterList.some(function (b) {
                return a.label == b;
              });
            }).filter(function (a) {
              return $mn.layers.getVisible().some(function (b) {
                return a.label == b.getProperty('group');
              });
            }); // debugger;
            //app.tags.mapLegend.update({ opts: { dataLegend: legfilter.legend, clearLegend:true } })

            app.maplegend.init(legfilter.legend).update();
          }

          $mn.one('bounds/changed', legendRefresh);
        }, 500);
      } else {
        $mn.one('bounds/changed', legendRefresh);
      }
    }
  }

  _legend.legend.filter.callBack = function (options) {
    if (options === false) {
      $mn.isMap().data.forEach(function (a) {
        if (a.getProperty('feature') == _feature) {
          a.setProperty('visible', true);
          $mn.isMap().data.overrideStyle(a, {
            visible: true
          });
        }
      });
      _filterList = [];
      _filterActive = false;
    } else {
      var good = options.reduce(function (r, p) {
        if (p.checked) r.push(p.label);
        return r;
      }, []);
      var bad = options.reduce(function (r, p) {
        if (!p.checked) r.push(p.label);
        return r;
      }, []);
      _filterActive = true;
      _filterList = good;
      $mn.isMap().data.forEach(function (a) {
        if (a.getProperty('feature') == _feature) {
          var visible = good.some(function (b) {
            return b == a.getProperty('group');
          });
          a.setProperty('visible', visible);
          $mn.isMap().data.overrideStyle(a, {
            visible: visible
          });
        }
      });
    }
  };

  $mn.on('layer/loaded/' + _feature, function (list) {
    _lib.ajax.$get('/app/router/trees.php?types', function (data) {
      data = JSON.parse(data);
      data.forEach(function (a) {
        _legend.legend.list.push({
          line: a.color,
          label: a.group
        });

        _legend.legend.filter.options.push({
          label: a.group
        });
      });
      var legfilter = {
        legend: {
          list: [],
          filter: _legend.legend.filter
        }
      };
      legfilter.legend.list = _legend.legend.list.filter(function (a) {
        return $mn.layers.getVisible().some(function (b) {
          return a.label == b.getProperty('group');
        });
      });
      app.maplegend.init(legfilter.legend).update(); // app.tags.map.update(legfilter)
    });

    $mn.layers.getVisible().forEach(function (a) {
      return $mn.isMap().data.overrideStyle(a, {
        visible: true
      });
    });
    _visible = true;
    $mn.one('bounds/changed', legendRefresh);
  });
  var _icon = '/assets/publica/sets/Find_Pin_Map.svg';
  app.on('map/feature/style', function (feat, style) {
    // {feat, style}
    // return
    var _style = {};

    if (feat.getProperty('feature') == _feature) {
      var _icon = '/assets/publica/scripts/Find_Pin.php?color=' + encodeURIComponent(feat.getProperty('color')); // console.log(_visible, feat.getProperty("visible"), (feat.getProperty("visible") !== false), _visible || (feat.getProperty("visible") !== false))


      var v = _visible;

      if (typeof feat.getProperty('visible') == 'boolean') {
        v = feat.getProperty('visible');
      }

      riot.util.misc.extend(_style, {
        icon: {
          url: _icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: '#3b69b2',
        visible: v
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "walkingtracks";
  var _page = "walkingtracks";
  var _icon = "assets/icons/black/mountain-bike.png";
  var _legend = {
    legend: {
      list: [{
        line: "purple",
        label: "Walking tracks"
      }, {
        line: "orange",
        label: "Shared use"
      }, {
        line: "blue",
        label: "Access path"
      }, {
        line: "black",
        label: "Closed track"
      }
      /*  { line: "black", label: "Planned shutoffs" }, */
      ]
    }
  };
  $mn.on("layer/loaded/" + _feature, function (list) {
    //app.tags.map.update(_legend);
    app.maplegend.init(_legend.legend).update();
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Walking tracks directory",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("name"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature || a.getProperty("feature") == _page;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("name"),
        desc: a.getProperty("status"),
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });
  /* 
      app.on("search/query", function(q, cb, register) {
          register(_feature, true);
          _lib.ajax.$get("/app/router/search.php?mtbtracks&q=" + q, function(data) {
              var results = [];
              var json = JSON.parse(data);
              if (json && Array.isArray(json.list))
                  json.list.forEach(function(item) {
                      results.push({
                          options: json.options,
                          label: item.label,
                          type: "MTB Tracks",
                          dataset: "mtbtracks",
                          obj: item,
                          image: _icon
                      });
                  });
              cb(results, _feature);
          });
      }); */

  /* app.on("map/legend/check/" + _feature, function(obj) {
      obj.hide = false;
  }); */

  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};
    var visible = true;

    if (feat.getProperty("feature") == _feature) {
      var zIndex = 5;

      if (feat.getGeometry() && feat.getGeometry().getType() == "Polygon") {
        zIndex = 0;
      }

      var color = "purple";

      if (feat.getProperty("data").properties.routeshareduse == "Yes") {
        color = "orange";
      } else if (feat.getProperty("data").properties.routehierarchy == "Connector") {
        color = "blue";
      }

      switch (feat.getProperty("status")) {
        case "Closed":
        case "closed":
        case "Avoid":
        case "avoid":
          color = "black";
          break;
      }

      if (feat.getProperty("traffic") == "Walk") {
        visible = true;
      } else {
        visible = false;
      }

      riot.util.misc.extend(_style, {
        strokeColor: color,
        strokeWeight: 4,
        strokeOpacity: 0.8,
        zIndex: zIndex,
        visible: visible
      });
    }

    riot.util.misc.extend(style, _style);
  }); //app.on("map/feature/detail/" + _feature, function (map, f, e) {

  var _mapDetail = function _mapDetail(map, f, e) {
    var feat = f;
    console.log(feat);
    var details = [{
      svgIcon: "Status",
      label: "status",
      value: feat.getProperty("status")
    }, {
      svgIcon: "Distance",
      label: "distance",
      value: feat.getProperty("data").properties.drvroutedistance
    }, {
      svgIcon: "Duration",
      label: "time",
      value: feat.getProperty("data").properties.drvroutetraveltime
    }, {
      label: "dogs",
      value: feat.getProperty("data").properties.routedogrestriction
    }, {
      label: "description",
      value: feat.getProperty("desc")
    }];

    if (feat.getProperty("data").properties.interneturl) {
      details.push({
        label: "more information",
        value: feat.getProperty("data").properties.interneturl,
        link: feat.getProperty("data").properties.interneturl
      });
    }

    var popup = {
      detail: true,
      data: {
        title: feat.getProperty("name"),
        sub: feat.getProperty("data").properties.routearea,
        details: details //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
  };

  app.on("map/feature/detail/" + _feature, _mapDetail);
})(app, riot);

(function (app, riot) {
  var _feature = "water-quality";
  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      return {
        icon: getIcon(a),
        name: a.getProperty("Name"),
        desc: a.getProperty("Grade").split(",").shift(),
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Water quality directory",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("Name"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var feat = f;
    var popup = {
      detail: true,
      data: {
        title: feat.getProperty("Name"),
        sub: feat.getProperty("Grade"),
        details: [{
          svgIcon: "Warning",
          label: "Warning",
          value: feat.getProperty("Warning")
        }, {
          label: "Link",
          html: "<a href='https://www.lawa.org.nz" + f.getProperty("Link") + "' target=_blank>More information - LAWA</a>"
        }] //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
  });

  function getIcon(feat) {
    var url = "/assets/pointer/web-pointers-waterdrop.svg";
    var verygood = "/assets/pointer/water/very-good.svg";
    var good = "/assets/pointer/water/good.svg";
    var fair = "/assets/pointer/water/fair.svg";
    var poor = "/assets/pointer/water/poor.svg";
    var verypoor = "/assets/pointer/water/very-poor.svg";
    var warning = "/assets/pointer/water/warning.svg";
    if (feat.getProperty("Grade").toLowerCase() == "very good") url = verygood;
    if (feat.getProperty("Grade").toLowerCase() == "good") url = good;
    if (feat.getProperty("Grade").toLowerCase() == "fair") url = fair;
    if (feat.getProperty("Grade").toLowerCase() == "poor") url = poor;
    if (feat.getProperty("Grade").toLowerCase() == "very poor") url = verypoor;
    if (feat.getProperty("Grade").toLowerCase() == "warning") url = warning;
    return url;
  }

  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      var url = getIcon(feat); //if (feat.getProperty("Grade").strtolower() == "very good") url = verygood;

      riot.util.misc.extend(_style, {
        icon: {
          url: url,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "waterfountains";
  var _feature2 = "porthills-water";
  var _icon = "/assets/publica/sets/Find_Pin_Map.svg"; //"/assets/c/drinkingfountain-mapmarker.svg";

  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("name"),
        desc: "",
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Water fountain directory",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("name"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var popup = {
      detail: true,
      data: {
        title: f.getProperty("name"),
        sub: "",
        details: [{
          label: "material",
          value: f.getProperty("material")
        }, {
          label: "dog",
          value: f.getProperty("dog")
        }, {
          label: "bottle",
          value: f.getProperty("bottle")
        }] //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
    return;
    var html = f.getProperty("name");

    if (f.getProperty("material") && f.getProperty("material") != "NULL") {
      html += "<br>" + f.getProperty("material");
    }

    if (f.getProperty("dog")) {
      html += "<br>Dog Bowl";
    }

    if (f.getProperty("bottle")) {
      html += "<br>Water bottle filler";
    }

    var data = {
      location: {
        lat: e.latLng.lat(),
        lng: e.latLng.lng()
      },
      detail: {
        name: html
      }
    };
    var popup = {
      detail: true,
      content: html,
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {}; //  url: "/assets/c/drinkingfountain-mapmarker.svg",

    if (feat.getProperty("feature") == _feature || feat.getProperty("feature") == _feature2) {
      riot.util.misc.extend(_style, {
        icon: {
          //  url: "/assets/pointer/web-pointers-drinking-fountain-33.svg",
          url: _icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "watershutoffs";
  var _icon = "/assets/pointer/web-pointers-watershutoff.svg";
  var _legend = {
    legend: {
      list: [{
        icon: "/assets/pointer/web-pointers-watershutoff.svg",
        label: "Past shutoffs"
      }, {
        icon: "/assets/pointer/web-pointers-watershutoff-red.svg",
        label: "Current shutoffs"
      }
      /*  { line: "black", label: "Planned shutoffs" }, */
      ]
    }
  };
  $mn.on("layer/loaded/" + _feature, function (list) {
    //app.tags.map.update(_legend);
    app.maplegend.init(_legend.legend).update();
  });
  /*  app.on("map/legend/check/" + _feature, function(obj) {
       obj.hide = false;
   }); */

  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("Address"),
        desc: a.getProperty("EventDateTime"),
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Water shutoff directory",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("Address"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var feat = f;
    var popup = {
      detail: true,
      data: {
        title: feat.getProperty("Address"),
        sub: feat.getProperty("EventDateTime"),
        details: [{
          svgIcon: "Status",
          label: "active",
          value: f.getProperty("IsActive") == 1 ? "Yes" : "No"
        }, {
          label: "Type",
          value: feat.getProperty("ShutdownType")
        }, {
          label: "Affected customers",
          value: feat.getProperty("EffectedProperties")
        }, {
          svgIcon: "Duration",
          label: "Estimated hours off",
          value: feat.getProperty("EstHoursOff")
        }] //content: html

      } // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
    return;
    var html = f.getProperty("Address");
    html += "<br>" + f.getProperty("EventDateTime");
    /*  "EventDateTime" => compactTime($feat["EventDateTime"]),
             "Address" => ($feat["Address"]),
          
             "ShutdownType" => $feat["ShutdownType"],
             "EstHoursOff" => $feat["EstHoursOff"],
             "EffectedProperties" => $feat["EffectedProperties"],*/

    html += "<br>Is active: " + (f.getProperty("IsActive") == 1 ? "Yes" : "No");
    html += "<br>Type: " + f.getProperty("ShutdownType");
    html += "<br>Affected customers " + f.getProperty("EffectedProperties");
    html += "<br>Estimated hours off " + f.getProperty("EstHoursOff");
    var popup = {
      detail: true,
      content: html,
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      var icon = _icon;
      var zindex = 1;

      if (feat.getProperty("IsActive") == 1) {
        icon = "/assets/pointer/web-pointers-watershutoff-red.svg";
        zindex = 2;
      }
      /* else {
                      icon = "/assets/pointer/web-pointers-watershutoff-gray.svg";
                      zindex = 0;
                  }*/


      riot.util.misc.extend(_style, {
        icon: {
          url: icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2",
        zIndex: zindex
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "water-level";
  var _icon = "/assets/publica/sets/Environment_Pin_Map.svg"; //"/assets/c/waterlevel-mapmarker.svg";

  app.on("map/features/list/callback", function (data) {
    var list = data.list.filter(function (a) {
      return a.getProperty("feature") == _feature;
    }).map(function (a) {
      return {
        icon: _icon,
        name: a.getProperty("Name"),
        desc: a.getProperty("Flow"),
        location: a.getGeometry(),
        feat: a
      };
    });
    data.cb(list);
  });
  /* app.on('map/legend/check/' + _feature, function(obj) {
      obj.hide = false
  }); */

  $mn.on("layer/loaded/" + _feature, function (list) {
    var _legend = {
      legend: {
        list: []
      }
    };

    _legend.legend.list.push({
      line: "linear-gradient(to right, rgb(255, 255, 0), rgb(0, 255, 0))",
      label: "River height from low to average"
    });

    _legend.legend.list.push({
      line: "linear-gradient(to right, rgb(0, 255, 0), blue)",
      label: "River height from average to high"
    }); //app.tags.map.update(_legend);


    app.maplegend.init(_legend.legend).update();
  });

  function showDirectory(list) {
    app.alert.set({
      title: "Water level directory",
      list: list.reduce(function (r, a) {
        r.push({
          title: a.getProperty("Name"),
          feat: a
        });
        return r;
      }, []),
      collapsed: true
    });
  }

  app.on("map/data/" + _feature, showDirectory);
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var feat = f;
    var details = [{
      svgIcon: "HighTide",
      label: "Stage",
      value: feat.getProperty("Stage")
    }, {
      svgIcon: "Avg",
      label: "Stage Avg",
      value: feat.getProperty("StageAvg")
    }, {
      svgIcon: "Max",
      label: "Stage Max",
      value: feat.getProperty("StageMax")
    }, {
      svgIcon: "HighTide",
      label: "Stage Min",
      value: feat.getProperty("StageMin")
    }];

    if (feat.getProperty("Flow") > 0) {
      details.push({
        svgIcon: "Grade",
        label: "Flow",
        value: feat.getProperty("Flow")
      });
      details.push({
        svgIcon: "Avg",
        label: "Flow Avg",
        value: feat.getProperty("FlowAvg")
      });
      details.push({
        svgIcon: "Max",
        label: "Flow Max",
        value: feat.getProperty("FlowMax")
      });
      details.push({
        svgIcon: "Grade",
        label: "Flow Min",
        value: feat.getProperty("FlowMin")
      });
    }

    var popup = {
      /*   detail: true, */
      tag: "popup-waterlevel",
      data: {
        title: feat.getProperty("Name"),
        sub: "",
        details: details //content: html

      },
      content: {
        name: feat.getProperty("Name")
      },
      openDetails: true // marker: feat

    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      var frac = 0;
      var s = parseFloat(feat.getProperty("Stage"));
      var as = parseFloat(feat.getProperty("StageAvg"));
      var xs = parseFloat(feat.getProperty("StageMax"));
      var ms = parseFloat(feat.getProperty("StageMin"));

      if (s < as) {
        frac = (s - ms) / (as - ms);
        frac /= 2;
      } else if (s > as) {
        frac = (s - ms) / (xs - ms);
        frac /= 2;
        frac += 0.5;
      } else {
        frac = 0.5;
      }

      var color = _lib.colorGradient(frac, {
        red: 255,
        green: 255,
        blue: 0
      }, {
        red: 0,
        green: 255,
        blue: 0
      }, {
        red: 0,
        green: 0,
        blue: 255
      });

      color = 'rgb(' + Math.max(0, color.red) + ',' + Math.max(0, color.green) + ',' + Math.max(0, color.blue) + ')'; //   console.log(color, frac, s, as, ms, xs);

      var _icon = '/assets/publica/scripts/Find_Pin.php?color=' + encodeURIComponent(color);

      riot.util.misc.extend(_style, {
        icon: {
          url: _icon,
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);

(function (app, riot) {
  var _feature = "webcams";
  app.on("map/feature/detail/" + _feature, function (map, f, e) {
    var html = f.getProperty("name");
    /* html += "<br>Available bikes: " + f.getProperty("bikes");
    html += "<br>Free racks: " + f.getProperty("free_racks"); */

    var data = {
      location: {
        lat: e.latLng.lat(),
        lng: e.latLng.lng()
      },
      detail: {
        name: f.getProperty("name"),
        info: [
          /*  { label: "Grade", text: f.getProperty("Grade") },
           { label: "Warning", text: f.getProperty("Warning") } */
        ]
      }
    };
    var popup = {
      detail: true,
      content: html,
      marker: f
    };
    app.tags.map.update({
      popup: popup
    });
  });
  app.on("map/feature/style", function (feat, style) {
    // {feat, style}
    var _style = {};

    if (feat.getProperty("feature") == _feature) {
      riot.util.misc.extend(_style, {
        icon: {
          url: feat.getProperty("path"),
          scaledSize: app.conf.mapIconSize()
        },
        strokeColor: "#3b69b2"
      });
    }

    riot.util.misc.extend(style, _style);
  });
})(app, riot);